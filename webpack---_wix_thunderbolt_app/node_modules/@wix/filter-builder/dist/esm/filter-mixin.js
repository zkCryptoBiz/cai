import { isArray, isFunction } from './type-utils';
import clone from './clone';
import { FilterValidator } from './filter-validator';
import { optimisedQuery } from './query-optimiser';
const filterMixin = (Base = class {
}) => class extends Base {
    constructor(obj = {}) {
        super(obj);
        this.filterTree = obj.filterTree || { $and: [] };
        this.invalidArguments = obj.invalidArguments || [];
        this.encoder = obj.encoder || {};
    }
    eq(...args) {
        return this._binaryAnd('$eq', '.eq', args);
    }
    ne(...args) {
        return this._binaryAnd('$ne', '.ne', args);
    }
    ge(...args) {
        return this._AndLogicalEquivalence('$gte', '.ge', args);
    }
    gt(...args) {
        return this._AndLogicalEquivalence('$gt', '.gt', args);
    }
    le(...args) {
        return this._AndLogicalEquivalence('$lte', '.le', args);
    }
    lt(...args) {
        return this._AndLogicalEquivalence('$lt', '.lt', args);
    }
    isNotEmpty(field) {
        const [newInvalidArguments, valid] = this._filterValidator('.isNotEmpty')
            .arityIsOne(arguments)
            .validFieldName(field)
            .validateAndAggregate();
        if (valid) {
            return this.ne(field, null);
        }
        return this._copy(this.filterTree, newInvalidArguments);
    }
    isEmpty(field) {
        const [newInvalidArguments, valid] = this._filterValidator('.isEmpty')
            .arityIsOne(arguments)
            .validFieldName(field)
            .validateAndAggregate();
        if (valid) {
            return this.eq(field, null);
        }
        return this._copy(this.filterTree, newInvalidArguments);
    }
    startsWith(...args) {
        return this._AndStringOperand('$startsWith', '.startsWith', args);
    }
    endsWith(...args) {
        return this._AndStringOperand('$endsWith', '.endsWith', args);
    }
    contains(...args) {
        return this._AndStringOperand('$contains', '.contains', args);
    }
    hasSome(...args) {
        return this._AndSetOperand('$hasSome', '.hasSome', args);
    }
    hasAll(...args) {
        return this._AndSetOperand('$hasAll', '.hasAll', args);
    }
    or(orQuery) {
        const [newInvalidArguments, valid] = this._filterValidator('.or')
            .arityIsOne(arguments)
            .isInstanceOfSameClass(orQuery)
            .validateAndAggregate();
        if (valid) {
            const prefix = isEmptyAnd(this.filterTree) ? [] : [this.filterTree];
            return this._copy(inAnd({ $or: [...prefix, orQuery.filterTree] }), newInvalidArguments.concat(orQuery.invalidArguments));
        }
        else {
            return this._copy(this.filterTree, newInvalidArguments);
        }
    }
    and(andQuery) {
        const [newInvalidArguments, valid] = this._filterValidator('.and')
            .arityIsOne(arguments)
            .isInstanceOfSameClass(andQuery)
            .validateAndAggregate();
        if (valid) {
            const prefix = isEmptyAnd(this.filterTree) ? [] : [this.filterTree];
            return this._copy(inAnd(...prefix, andQuery.filterTree), newInvalidArguments.concat(andQuery.invalidArguments));
        }
        else {
            return this._copy(this.filterTree, newInvalidArguments);
        }
    }
    not(notQuery) {
        const [newInvalidArguments, valid] = this._filterValidator('.not')
            .arityIsOne(arguments)
            .isInstanceOfSameClass(notQuery)
            .validateAndAggregate();
        if (valid) {
            const newFilterTree = clone(this.filterTree);
            const notClause = { $not: [notQuery.filterTree] };
            const resultingFilter = inAndOptimized(newFilterTree, notClause);
            return this._copy(resultingFilter, newInvalidArguments.concat(notQuery.invalidArguments));
        }
        else {
            return this._copy(this.filterTree, newInvalidArguments);
        }
    }
    between(field, rangeStart, rangeEnd) {
        const [newInvalidArguments, valid] = this._filterValidator('.between')
            .arityIsThree(arguments)
            .sameType(rangeStart, rangeEnd)
            .typeIsStringNumberOrDate(rangeStart)
            .typeIsStringNumberOrDate(rangeEnd)
            .validateAndAggregate();
        if (valid) {
            return this.ge(field, rangeStart).lt(field, rangeEnd);
        }
        return this._copy(this.filterTree, newInvalidArguments);
    }
    getFilterModel() {
        if (this.invalidArguments.length > 0) {
            throw new Error(this.invalidArguments.join(' '));
        }
        return optimisedQuery(this.filterTree);
    }
    setFilterModel(filterModel) {
        return this._copy(filterModel, []);
    }
    _binaryAnd(filterOperatorSymbol, operatorName, args) {
        const [field, operand] = Array.prototype.slice.call(args);
        const [newInvalidArguments] = this._filterValidator(operatorName)
            .arityIsTwo(args)
            .validFieldName(field)
            .validateAndAggregate();
        const newFilterTree = this._makeNewFilter(field, filterOperatorSymbol, operand);
        return this._copy(newFilterTree, newInvalidArguments);
    }
    _AndLogicalEquivalence(filterOperatorSymbol, operatorName, args) {
        const [field, operand] = Array.prototype.slice.call(args);
        const [newInvalidArguments] = this._filterValidator(operatorName)
            .arityIsTwo(args)
            .validFieldName(field)
            .typeIsStringNumberOrDate(operand)
            .validateAndAggregate();
        const newFilterTree = this._makeNewFilter(field, filterOperatorSymbol, operand);
        return this._copy(newFilterTree, newInvalidArguments);
    }
    _AndStringOperand(filterOperatorName, operatorName, args) {
        const [field, operand] = Array.prototype.slice.call(args);
        const [newInvalidArguments] = this._filterValidator(operatorName)
            .arityIsTwo(args)
            .validFieldName(field)
            .typeIsString(operand)
            .validateAndAggregate();
        const newFilterTree = this._makeNewFilter(field, filterOperatorName, operand);
        return this._copy(newFilterTree, newInvalidArguments);
    }
    _AndSetOperand(filterOperatorName, operatorName, args) {
        const [field, ...rawOperands] = Array.prototype.slice.call(args);
        const operands = isArray(rawOperands[0]) ? rawOperands[0] : rawOperands;
        const [newInvalidArguments] = this._filterValidator(operatorName)
            .arityIsAtLeastTwo(args)
            .validFieldName(field)
            .typeIsStringNumberOrDateForAll(operands)
            .validateAndAggregate();
        const newFilterTree = this._makeNewFilter(field, filterOperatorName, operands);
        return this._copy(newFilterTree, newInvalidArguments);
    }
    _makeNewFilter(field, filterOperatorName, operand) {
        const newFilterTree = clone(this.filterTree);
        const serializableOperand = operand === undefined ? null : operand;
        const newFilter = this._buildFilter(field, filterOperatorName, serializableOperand);
        if (isArray(newFilterTree.$and)) {
            newFilterTree.$and.push(newFilter);
            return newFilterTree;
        }
        else {
            const result = isEmptyObject(newFilterTree)
                ? inAnd(newFilter)
                : inAnd(newFilterTree, newFilter);
            return result;
        }
    }
    _buildFilter(field, filterOperatorName, operand) {
        if (filterOperatorName !== '$eq') {
            const newFilter = {};
            newFilter[field] = {};
            newFilter[field][filterOperatorName] = this._encode(operand);
            return newFilter;
        }
        else {
            const newFilter = {};
            newFilter[field] = this._encode(operand);
            return newFilter;
        }
    }
    _encode(operand) {
        if (isFunction(this.encoder)) {
            return this.encoder(operand);
        }
        else {
            return operand;
        }
    }
    _copy(filterTree, invalidArguments) {
        return new this.constructor({ ...this, filterTree, invalidArguments });
    }
    _filterValidator(filterOperatorName) {
        return new FilterValidator(filterOperatorName, this.invalidArguments, this.constructor);
    }
};
function isConjunctiveFormFilter(filterTree) {
    return isArray(filterTree.$and);
}
function isEmptyObject(obj) {
    return Object.keys(obj).length === 0;
}
function inAnd(...args) {
    return {
        $and: args,
    };
}
function inAndOptimized(...args) {
    return {
        $and: args.reduce((aggr, val) => isConjunctiveFormFilter(val)
            ? aggr.concat(val.$and)
            : aggr.concat([val]), []),
    };
}
function isEmptyAnd(node) {
    return node && node.$and && node.$and.length === 0;
}
export default filterMixin;
//# sourceMappingURL=filter-mixin.js.map