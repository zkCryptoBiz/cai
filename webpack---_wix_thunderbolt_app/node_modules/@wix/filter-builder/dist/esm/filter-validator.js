import { typeForDisplay, isDate, isString, isNumber } from './type-utils';
import clone from './clone';
export class FilterValidator {
    constructor(operatorName, previousInvalidArguments, ctor) {
        this._validations = [];
        this.operatorName = operatorName;
        this.ctor = ctor;
        this._invalidArguments = clone(previousInvalidArguments);
    }
    typeIsString(value) {
        return this.addValidation(() => isString(value), () => `Invalid ${this.operatorName} parameter value [${typeForDisplay(value)}]. ${this.operatorName} parameter must be a String.`);
    }
    typeIsStringNumberOrDate(value) {
        return this.addValidation(() => isDateStringOrNumber(value), () => `Invalid ${this.operatorName} parameter value [${typeForDisplay(value)}]. Valid ${this.operatorName} parameter types are String, Number or Date.`);
    }
    sameType(first, second) {
        return this.addValidation(() => typeForDisplay(first) === typeForDisplay(second), () => `Invalid ${this.operatorName} parameter values [${typeForDisplay(first)}] and [${typeForDisplay(second)}]. Both parameters must be of the same type.`);
    }
    typeIsStringNumberOrDateForAll(values) {
        return this.addValidation(() => values.every(isDateStringOrNumber), () => `Invalid ${this.operatorName} usage. ${this.operatorName} supports only Number, String or Date items.`);
    }
    validFieldName(field) {
        return this.addValidation(() => isString(field), () => `Invalid ${this.operatorName} field value [${typeForDisplay(field)}]. ${this.operatorName} field must be a String.`);
    }
    isInstanceOfSameClass(obj) {
        return this.addValidation(() => obj instanceof this.ctor, () => `Invalid ${this.operatorName} parameter [${typeForDisplay(obj)}]. ${this.operatorName} expects FilterBuilder only.`);
    }
    arityIsOne(args) {
        return this.addValidation(() => args.length === 1, () => `Invalid ${this.operatorName} usage. ${this.operatorName} requires one parameter.`);
    }
    arityIsTwo(args) {
        return this.addValidation(() => args.length === 2, () => `Invalid ${this.operatorName} usage. ${this.operatorName} requires two parameters.`);
    }
    arityIsThree(args) {
        return this.addValidation(() => args.length === 3, () => `Invalid ${this.operatorName} usage. ${this.operatorName} requires three parameters.`);
    }
    arityIsAtLeastTwo(args) {
        return this.addValidation(() => args.length >= 2, () => `Invalid ${this.operatorName} usage. ${this.operatorName} requires at least two parameters.`);
    }
    addValidation(predicateFn, messageFn) {
        this._validations.push({
            predicateFn,
            messageFn,
        });
        return this;
    }
    validateAndAggregate() {
        const valid = this._validations.every(({ predicateFn, messageFn }) => this._appendIfInvalid(predicateFn(), messageFn()));
        return [this._invalidArguments, valid];
    }
    _appendIfInvalid(valid, message) {
        if (!valid) {
            this._invalidArguments.push(message);
            return false;
        }
        return true;
    }
}
function isDateStringOrNumber(value) {
    return isString(value) || isNumber(value) || isDate(value);
}
//# sourceMappingURL=filter-validator.js.map