import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { reportErrorBi } from './reportErrorBi';
import { createErrorResolution } from './createErrorResolution';
import { createBiLoggerWithDefaults } from '../util/createBiLoggerWithDefaults';
import { ErrorAccessor } from '../state/ErrorAccessor';
import { TranslationsState } from '../state/TranslationsState';
import { reportErrorResolutionBi } from './reportErrorResolutionBi';
import { v4 as uuid } from 'uuid';
import { reportGetResolvedErrorBi } from './reportGetResolvedErrorBi';
import { reportShowErrorBi } from './reportShowErrorBi';
export class ErrorHandler {
  constructor(params) {
    _defineProperty(this, "biLogger", void 0);
    _defineProperty(this, "errorMonitor", void 0);
    _defineProperty(this, "experiments", void 0);
    _defineProperty(this, "platformShowError", void 0);
    _defineProperty(this, "translations", void 0);
    _defineProperty(this, "onlineManager", void 0);
    _defineProperty(this, "webWindow", void 0);
    _defineProperty(this, "handleError", async error => {
      if (this._isErrorHandlerDisabled()) {
        return;
      }
      const {
        errorMonitor
      } = this;
      try {
        const errorAccessor = new ErrorAccessor({
          error
        });
        this._setErrorHandlerSessionId(errorAccessor);
        reportErrorBi(this, {
          errorAccessor
        });
      } catch (e) {
        console.error(e);
        errorMonitor.captureException(e);
      }
    });
    _defineProperty(this, "withErrorHandler", async (fn, options) => {
      try {
        return await fn();
      } catch (error) {
        await this._resolveError(error, options);
        throw error;
      }
    });
    _defineProperty(this, "getResolvedError", error => {
      const {
        errorMonitor
      } = this;
      try {
        const errorAccessor = new ErrorAccessor({
          error
        });
        const {
          applicationError,
          httpError,
          error: e
        } = errorAccessor;
        const resolvedError = e == null ? void 0 : e._errorHandlerResolvedError;
        reportGetResolvedErrorBi(this, {
          errorAccessor
        });
        return {
          message: (resolvedError == null ? void 0 : resolvedError.message) ?? "This action wasn't completed due to a technical issue.",
          action: resolvedError == null ? void 0 : resolvedError.action,
          applicationError: applicationError,
          httpError,
          requestId: httpError == null ? void 0 : httpError.requestId
        };
      } catch (e) {
        console.error(e);
        errorMonitor.captureException(e);
        throw e;
      }
    });
    _defineProperty(this, "showError", (error, props) => {
      const {
        platformShowError,
        errorMonitor
      } = this;
      if (!platformShowError) {
        return;
      }
      try {
        const errorAccessor = new ErrorAccessor({
          error
        });
        const {
          error: e
        } = errorAccessor;
        const resolvedError = e == null ? void 0 : e._errorHandlerResolvedError;
        const showErrorProps = props ?? resolvedError;
        reportShowErrorBi(this, {
          showErrorProps,
          errorAccessor
        });
        if (!showErrorProps) {
          return;
        }
        const {
          message,
          action
        } = showErrorProps;
        platformShowError({
          message,
          action: action != null && action.onClick ? {
            text: action.text,
            onClick: action.onClick
          } : undefined
        });
      } catch (e) {
        console.error(e);
        errorMonitor.captureException(e);
      }
    });
    this.biLogger = createBiLoggerWithDefaults(params);
    this.errorMonitor = params.createErrorMonitor({
      dsn: 'https://831e1d96e7944c6aae0c9ed9d6babd35@sentry.wixpress.com/5896'
    });
    this.experiments = params.createExperiments == null ? void 0 : params.createExperiments({
      scopes: ['error-handler']
    });
    this.platformShowError = params.showError;
    this.translations = new TranslationsState(params);
    this.onlineManager = params.onlineManager ?? navigator;
    this.webWindow = typeof window !== 'undefined' ? window : undefined;
  }
  _setErrorHandlerSessionId(errorAccessor) {
    const {
      error
    } = errorAccessor;
    if (!error) {
      return;
    }
    error._errorHandlerSessionId = uuid();
  }
  _setErrorHandlerResolvedError(errorAccessor, errorResolution) {
    const {
      error
    } = errorAccessor;
    if (!error) {
      return;
    }
    error._errorHandlerResolvedError = errorResolution.errorToShow;
  }
  _isErrorHandlerDisabled() {
    const {
      experiments
    } = this;
    return experiments != null && !experiments.enabled('specs.os.EnableErrorHandlerInEditor');
  }
  async _resolveError(error, options) {
    if (options === void 0) {
      options = {};
    }
    if (this._isErrorHandlerDisabled()) {
      return;
    }
    const {
      errorMonitor
    } = this;
    try {
      const errorAccessor = new ErrorAccessor({
        error
      });
      const errorResolution = await createErrorResolution(this, {
        errorAccessor,
        errorCodesMap: options.errorCodesMap
      });
      this._setErrorHandlerResolvedError(errorAccessor, errorResolution);
      reportErrorResolutionBi(this, {
        errorAccessor,
        errorResolution,
        errorCodesMap: options.errorCodesMap
      });
    } catch (e) {
      console.error(e);
      errorMonitor.captureException(e);
    }
  }
}
//# sourceMappingURL=ErrorHandler.js.map