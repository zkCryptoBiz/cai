import { handleJsonResponse, parseBulkDataItemsError, handleJsonErrorResponse, } from './platformized-data-response';
import { apiValidator, codes, validationError, messages, wixDataError, } from '@wix/wix-data-errors';
import { serializeDates, isArray, isObject, isString, isDate, isNumber, toPlatformizedAggregate, base64url, } from '@wix/wix-data-utils';
import { noopTraceWith } from './trace-with';
import toDataItemsAggregate from './dataItemsAggregate';
const isProvider = (candidate) => typeof candidate === 'object' &&
    candidate !== null &&
    'get' in candidate &&
    typeof candidate.get === 'function';
export var Environment;
(function (Environment) {
    Environment["LIVE"] = "LIVE";
    Environment["SANDBOX_PREFERRED"] = "SANDBOX_PREFERRED";
    Environment["SANDBOX"] = "SANDBOX";
})(Environment || (Environment = {}));
export class PlatformizedWixDataProvider {
    constructor({ cloudDataUrl = '/_api/cloud-data', gridAppId, environment, httpClient, authHeader, traceWith = noopTraceWith, }) {
        this.cloudDataUrl = cloudDataUrl;
        this.gridAppId = gridAppId;
        this.environment = environment;
        this.httpClientProvider =
            typeof httpClient === 'function' ? httpClient : () => httpClient;
        this.traceWith = traceWith;
        this.authHeader = authHeader;
    }
    _unwrapDataItems(items) {
        return items.map((item) => item.data);
    }
    _unwrapDataItem(response) {
        if (response &&
            response.hasOwnProperty('dataItem') &&
            response.dataItem.hasOwnProperty('data')) {
            return {
                item: response.dataItem.data,
            };
        }
        else {
            return response;
        }
    }
    insert(collectionName, item, options) {
        return this._traceWith('platformized-provider-insert', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .item(item, collectionName, false)
            .options(options)
            .validateAndReject()
            .then(() => this._post('/v2/items', {
            ..._flatOptions(options),
            dataCollectionId: collectionName,
            dataItem: {
                id: item._id,
                dataCollectionId: collectionName,
                data: item,
            },
        }, options))
            .then(this._unwrapDataItem));
    }
    update(collectionName, item, options) {
        return this._traceWith('platformized-provider-update', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .item(item, collectionName, false)
            .options(options)
            .validateAndReject()
            .then(() => this._post('/v2/items/update', {
            ..._flatOptions(options),
            dataCollectionId: collectionName,
            dataItem: {
                id: item._id,
                dataCollectionId: collectionName,
                data: item,
            },
        }, options))
            .then(this._unwrapDataItem));
    }
    save(collectionName, item, options) {
        return this._traceWith('platformized-provider-save', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .item(item, collectionName, false)
            .options(options)
            .validateAndReject()
            .then(() => this._post('/v2/items/save', {
            ..._flatOptions(options),
            dataCollectionId: collectionName,
            dataItem: {
                id: item._id,
                dataCollectionId: collectionName,
                data: item,
            },
        }, options))
            .then(this._unwrapDataItem));
    }
    truncate(collectionName, options) {
        return this._traceWith('platformized-provider-truncate', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .validateAndReject()
            .then(() => this._post('/v2/items/truncate', {
            dataCollectionId: collectionName,
        }, options))
            .then(() => Promise.resolve(null)));
    }
    remove(collectionName, itemId, options) {
        return this._traceWith('platformized-provider-remove', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .itemId(itemId)
            .options(options)
            .validateAndReject()
            .then(() => this._post('/v2/items/remove', {
            ..._flatOptions(options),
            dataCollectionId: collectionName,
            dataItemId: itemId,
        }, options))
            .then(this._unwrapDataItem)
            .catch((err) => {
            if (err && err.code === codes.ItemDoesNotExist) {
                return Promise.resolve(null);
            }
            return Promise.reject(err);
        }));
    }
    bulkRemove(collectionName, itemIds, options) {
        return this._traceWith('platformized-provider-bulk-remove', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .itemIds(itemIds, collectionName)
            .bulkRemoveOptions(options)
            .validateAndReject()
            .then(() => {
            if (itemIds.length === 0) {
                return {
                    removedItemIds: [],
                    removed: 0,
                    skipped: 0,
                    errors: [],
                };
            }
            return this._post('/v2/bulk/items/remove', {
                ..._flatOptions(options),
                dataCollectionId: collectionName,
                dataItemIds: itemIds,
            }, options)
                .then(({ results }) => {
                const successes = results.filter((result) => result.itemMetadata.success);
                // Thats the way wixData API worked with WixDataService. Non-existing items are skipped and not reported as errors.
                const errors = results.filter((result) => !result.itemMetadata.success &&
                    result.itemMetadata.error.code !== 'WDE0073');
                const removedItemIds = successes.map((result) => result.itemMetadata.id);
                return {
                    removedItemIds,
                    removed: removedItemIds.length,
                    skipped: itemIds.length - removedItemIds.length - errors.length,
                    errors: errors.map(parseBulkDataItemsError(itemIds)),
                };
            })
                .catch((err) => {
                if (err && err.code === codes.ItemDoesNotExist) {
                    return Promise.resolve(null);
                }
                return Promise.reject(err);
            });
        }));
    }
    get(collectionName, itemId, options) {
        return this._traceWith('platformized-provider-get', {
            collectionName,
            itemId,
        })(() => {
            return apiValidator()
                .collectionName(collectionName)
                .itemId(itemId)
                .options(options)
                .validateAndReject()
                .then(() => {
                const isSafeItemId = encodeURIComponent(itemId) === itemId;
                if (isSafeItemId) {
                    return this._get(`/v2/items/${itemId}`, {
                        ..._flatOptions(options),
                        dataCollectionId: collectionName,
                        dataItemId: itemId,
                    }, options);
                }
                else {
                    return this._post(`/v2/items/get`, {
                        ..._flatOptions(options),
                        dataCollectionId: collectionName,
                        dataItemId: itemId,
                    }, options);
                }
            })
                .then(this._unwrapDataItem)
                .catch((err) => {
                if (err && err.code === codes.ItemDoesNotExist) {
                    return Promise.resolve(null);
                }
                return Promise.reject(err);
            });
        });
    }
    find(collectionName, filter, order, skip, limit, options, include, omitTotalCount, cursor, projectedFields) {
        return this._traceWith('platformized-provider-find', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => this._validateOrderBy(collectionName, order))
            .then(() => this._validateFilter(collectionName, filter))
            .then(() => {
            const query = this._getDataQuery(filter, order, limit, skip, cursor, projectedFields);
            const referencedItemOptions = isArray(include)
                ? include.map((i) => ({ fieldName: i }))
                : undefined;
            return this._get('/v2/items/query', {
                ..._flatOptions(options),
                dataCollectionId: collectionName,
                query,
                referencedItemOptions,
                returnTotalCount: !omitTotalCount,
            }, options).then((response) => {
                const { dataItems, pagingMetadata } = response;
                const items = this._unwrapDataItems(dataItems);
                const isPartialIncludes = !!items.find((item) => {
                    return !!(isArray(include) &&
                        include.find((includedField) => {
                            const references = item[includedField];
                            return isArray(references) && references.length >= 50;
                        }));
                });
                return {
                    items,
                    partialIncludes: isPartialIncludes,
                    totalCount: pagingMetadata.total,
                    pagingMetadata,
                };
            });
        }));
    }
    runAggregate(collectionName, pipeline, pageSize, options, cursor) {
        return this._traceWith('platformized-provider-aggregate', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => {
            const platformizedPipeline = toPlatformizedAggregate(pipeline);
            return this._get('/v2/items/aggregate', {
                ..._flatOptions(options),
                dataCollectionId: collectionName,
                initialFilter: platformizedPipeline.preFilteringStep,
                aggregation: toDataItemsAggregate(platformizedPipeline.processingStep),
                finalFilter: platformizedPipeline.postFilteringStep,
                sort: this._platformizedSort(pipeline),
                ...this._getAggregatePaging(pipeline, pageSize, cursor),
            }, options).then((result) => {
                const { results, pagingMetadata: { cursors, hasNext }, } = result;
                const items = results.map((item) => {
                    // When grouping by one field WixDataService returns value on _id field directly, DataItemService wraps it in an object, i.e.
                    // grouping by surname returns {_id: 'Simpson'} in WixDataService vs {_id: {surname: 'Simpson'}} in DataItemService
                    // When grouping by more fields, values are kept wrapped.
                    if (typeof item._id === 'object' &&
                        Object.keys(item._id).length === 1) {
                        const flattened = item._id[Object.keys(item._id)[0]];
                        item._id = flattened;
                    }
                    return item;
                });
                return {
                    items,
                    hasNext,
                    cursors,
                };
            });
        }));
    }
    _platformizedSort(pipeline) {
        const sortStage = pipeline.find((stage) => stage.hasOwnProperty('$sort'));
        if (!sortStage) {
            return undefined;
        }
        const platformizedSort = sortStage.$sort.map((sortDefinition) => {
            const [fieldName, order] = Object.entries(sortDefinition)[0];
            return {
                fieldName,
                order: order === 'asc' ? 0 : 1,
            };
        });
        return platformizedSort;
    }
    _getDataQuery(filter, order, limit, skip, cursor, projectedFields) {
        return {
            filter,
            sort: order ? this._mapOrderToSort(order) : undefined,
            ...this._getPaging(limit, skip, cursor),
            fields: projectedFields,
        };
    }
    _getAggregatePaging(pipeline, limit, cursor) {
        const skipStage = pipeline.find((stage) => stage.hasOwnProperty('$skip'));
        const skip = skipStage !== undefined ? skipStage.$skip : undefined;
        return this._getPaging(limit, skip, cursor);
    }
    _getPaging(limit, skip, cursor) {
        if (cursor && skip > 0) {
            throw wixDataError(messages.cursorPagingDoesNotSupportSkip(), codes.ValidationError);
        }
        if (cursor) {
            return {
                cursorPaging: {
                    limit,
                    cursor,
                },
            };
        }
        else {
            return {
                paging: {
                    offset: skip,
                    limit,
                },
            };
        }
    }
    count(collectionName, filter, options) {
        return this._traceWith('platformized-provider-count', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => this._validateFilter(collectionName, filter))
            .then(() => this._get('/v2/items/count', {
            ..._flatOptions(options),
            dataCollectionId: collectionName,
            filter,
        }, options)));
    }
    _sortingFromOrder(order, fieldName) {
        const safeOrder = isArray(order) ? order : [];
        const maybeSortForField = safeOrder.find((o) => o.hasOwnProperty(fieldName));
        const sorting = maybeSortForField && maybeSortForField.hasOwnProperty(fieldName)
            ? maybeSortForField[fieldName]
            : undefined;
        return sorting ? sorting.toUpperCase() : sorting;
    }
    distinct(collectionName, filter, order, fieldName, skip, limit, options, cursor, projectedFields, omitTotalCount) {
        return this._traceWith('platformized-provider-distinct', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => this._validateOrderBy(collectionName, order))
            .then(() => this._validateFilter(collectionName, filter))
            .then(() => {
            const query = this._getDataQuery(filter, order, limit, skip, cursor, projectedFields);
            return this._get('/v2/items/query-distinct-values', {
                ..._flatOptions(options),
                dataCollectionId: collectionName,
                fieldName,
                filter: query.filter,
                order: this._sortingFromOrder(order, fieldName),
                paging: query.paging,
                cursorPaging: query.cursorPaging,
                ...(omitTotalCount ? {} : { returnTotalCount: true }),
            }, options).then(({ distinctValues, pagingMetadata }) => ({
                items: distinctValues,
                totalCount: pagingMetadata.total,
                pagingMetadata,
            }));
        }));
    }
    bulkInsert(collectionName, items, options) {
        return this._traceWith('platformized-provider-bulk-insert', {
            collectionName,
        })(() => {
            const overrideExisting = (options || {}).overrideExisting;
            return apiValidator()
                .collectionName(collectionName)
                .items(items, collectionName)
                .bulkInsertOptions(options)
                .validateAndReject()
                .then(() => {
                if (items.length === 0) {
                    return {
                        insertedItemIds: [],
                        inserted: 0,
                        errors: [],
                        skipped: 0,
                        updated: 0,
                    };
                }
                const path = overrideExisting
                    ? '/v2/bulk/items/save'
                    : '/v2/bulk/items/insert';
                return this._post(path, {
                    ..._flatOptions(options),
                    dataCollectionId: collectionName,
                    dataItems: items.map((item) => ({
                        id: item._id,
                        dataCollectionId: collectionName,
                        data: item,
                    })),
                }, options).then(({ results }) => {
                    const successes = results.filter((result) => result.itemMetadata.success);
                    const insertedItemIds = successes.map((result) => result.itemMetadata.id);
                    const inserted = successes.filter((result) => result.action === 'INSERT').length;
                    const updated = successes.filter((result) => result.action === 'UPDATE').length;
                    // in wix-data bulk API when item already exists it is not returned as error, but is counted as skipped.
                    const errors = results.filter((result) => !result.itemMetadata.success &&
                        result.itemMetadata.error.code !== 'WDE0074');
                    return {
                        insertedItemIds,
                        inserted,
                        skipped: overrideExisting
                            ? 0
                            : items.length - insertedItemIds.length - errors.length,
                        updated,
                        errors: errors.map(parseBulkDataItemsError(items)),
                    };
                });
            });
        });
    }
    bulkSave(collectionName, items, options) {
        return this._traceWith('platformized-provider-bulk-save', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .items(items, collectionName)
            .bulkInsertOptions(options)
            .validateAndReject()
            .then(() => {
            if (items.length === 0) {
                return {
                    insertedItemIds: [],
                    updatedItemIds: [],
                    inserted: 0,
                    updated: 0,
                    skipped: 0,
                    errors: [],
                };
            }
            return this._post('/v2/bulk/items/save', {
                ..._flatOptions(options),
                dataCollectionId: collectionName,
                dataItems: items.map((item) => ({
                    id: item._id,
                    dataCollectionId: collectionName,
                    data: item,
                })),
            }, options).then(({ results }) => {
                const successes = results.filter((result) => result.itemMetadata.success);
                const inserted = successes.filter((result) => result.action === 'INSERT');
                const updated = successes.filter((result) => result.action === 'UPDATE');
                const insertedItemIds = inserted.map((item) => item.itemMetadata.id);
                const updatedItemIds = updated.map((item) => item.itemMetadata.id);
                const errors = results.filter((result) => !result.itemMetadata.success);
                return {
                    insertedItemIds,
                    updatedItemIds,
                    inserted: inserted.length,
                    skipped: items.length -
                        insertedItemIds.length -
                        updatedItemIds.length -
                        errors.length,
                    updated: updated.length,
                    errors: errors.map(parseBulkDataItemsError(items)),
                };
            });
        }));
    }
    bulkUpdate(collectionName, items, options) {
        return this._traceWith('platformized-provider-bulk-update', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .items(items, collectionName)
            .bulkUpdateOptions(options)
            .validateAndReject()
            .then(() => {
            if (items.length === 0) {
                return {
                    updatedItemIds: [],
                    inserted: 0,
                    skipped: 0,
                    updated: 0,
                    errors: [],
                };
            }
            return this._post('/v2/bulk/items/update', {
                ..._flatOptions(options),
                dataCollectionId: collectionName,
                dataItems: items.map((item) => ({
                    id: item._id,
                    dataCollectionId: collectionName,
                    data: item,
                })),
            }, options).then(({ results }) => {
                const successes = results.filter((result) => result.itemMetadata.success);
                const updated = successes.filter((result) => result.action === 'UPDATE');
                const updatedItemIds = updated.map((item) => item.itemMetadata.id);
                // Non-existing items are skipped and not reported as errors.
                const errors = results.filter((result) => !result.itemMetadata.success &&
                    result.itemMetadata.error.code !== 'WDE0073');
                return {
                    updatedItemIds,
                    inserted: 0,
                    skipped: items.length - updatedItemIds.length - errors.length,
                    updated: updated.length,
                    errors: errors.map(parseBulkDataItemsError(items)),
                };
            });
        }));
    }
    queryReferenced(collectionName, holdingItem, propertyName, options) {
        return this._traceWith('platformized-provider-query-referenced', {
            collectionName,
            order: options.order,
            skip: options.skip,
            limit: options.limit,
            cursorExists: options.cursor ? 'true' : 'false',
        })(() => {
            options = options || {};
            const order = (options.order || 'ASC').toUpperCase();
            const offset = options.skip || 0;
            const limit = options.limit || 50;
            const cursor = options.cursor;
            return apiValidator()
                .collectionName(collectionName)
                .options(options)
                .validateAndReject()
                .then(() => this._get('/v2/items/query-referenced', {
                ..._flatOptions(options),
                dataCollectionId: collectionName,
                referringItemId: holdingItem,
                referringItemFieldName: propertyName,
                order,
                ...(options?.omitTotalCount ? {} : { returnTotalCount: true }),
                ...this._getPaging(limit, offset, cursor),
            }, options))
                .then(({ results, pagingMetadata }) => {
                const onlyReferencedItems = results
                    .filter((result) => !!result.dataItem)
                    .map((result) => result.dataItem.data);
                return {
                    items: onlyReferencedItems,
                    totalCount: pagingMetadata.total,
                    pagingMetadata,
                };
            });
        });
    }
    insertReference(collectionName, relationshipName, left, right, options) {
        return this._traceWith('platformized-provider-insert-reference', {
            collectionName,
        })(() => this.insertReferences(collectionName, [{ relationshipName, left, right }], options));
    }
    insertReferences(collectionName, references, options) {
        return this._traceWith('platformized-provider-insert-references', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => {
            const dataItemReferences = references.map(({ relationshipName, left, right }) => ({
                referringItemFieldName: relationshipName,
                referringItemId: left,
                referencedItemId: right,
            }));
            return this._post('/v2/bulk/items/insert-references', {
                ..._flatOptions(options),
                dataCollectionId: collectionName,
                dataItemReferences,
            }, options);
        }));
    }
    replaceReferences(collectionName, query, newReferences, options) {
        return this._traceWith('platformized-provider-replace-references', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => this._post('/v2/items/replace-references', {
            ..._flatOptions(options),
            dataCollectionId: collectionName,
            referringItemFieldName: query.relationshipName,
            referringItemId: query.left,
            newReferencedItemIds: newReferences.map(({ right }) => right),
        }, options)));
    }
    removeReference(collectionName, relationshipName, left, right, options) {
        return this._traceWith('platformized-provider-remove-reference', {
            collectionName,
        })(() => this.removeReferences(collectionName, [{ relationshipName, left, right }], options));
    }
    removeReferences(collectionName, references, options) {
        return this._traceWith('platformized-provider-remove-references', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => this._post('/v2/bulk/items/remove-references', {
            ..._flatOptions(options),
            dataCollectionId: collectionName,
            dataItemReferences: references.map(({ relationshipName, left, right }) => ({
                referringItemFieldName: relationshipName,
                referringItemId: left,
                referencedItemId: right,
            })),
        }, options)));
    }
    isReferenced(collectionName, propertyName, left, right, options) {
        return this._traceWith('platformized-provider-is-referenced', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => this._post('/v2/items/is-referenced', {
            ..._flatOptions(options),
            dataCollectionId: collectionName,
            referringItemFieldName: propertyName,
            referringItemId: left,
            referencedItemId: right,
        }, options))
            .then(({ isReferenced }) => isReferenced));
    }
    _mapOrderToSort(order) {
        return order.flatMap((o) => Object.entries(o).map(([key, value]) => ({
            fieldName: key,
            order: value.toUpperCase(),
        })));
    }
    _validateOrderBy(collectionName, order) {
        const isNotArray = (elem) => !isArray(elem);
        const isNotObject = (elem) => !isObject(elem);
        const isInvalidSort = (elem) => {
            const values = Object.values(elem);
            const isValid = values.length === 1 && (values[0] === 'asc' || values[0] === 'desc');
            return !isValid;
        };
        const nonArrayMessage = (elem) => messages.orderByValidations.sortModelType(elem);
        const nonObjectMessage = (elem) => messages.orderByValidations.sortModelItemType(elem);
        const invalidSortMessage = (elem) => messages.orderByValidations.sortModelItem(elem);
        if ([null, undefined].includes(order)) {
            return Promise.resolve();
        }
        if (isNotArray(order)) {
            return Promise.reject(this._validationError(collectionName, [nonArrayMessage(order)]));
        }
        const errors = order.flatMap((elem) => {
            if (isNotObject(elem)) {
                return nonObjectMessage(elem);
            }
            if (isInvalidSort(elem)) {
                return invalidSortMessage(elem);
            }
            return [];
        });
        return errors.length
            ? Promise.reject(this._validationError(collectionName, errors))
            : Promise.resolve();
    }
    _validateFilter(collectionName, filter) {
        const objectType = messages.filterTreeValidations.objectType;
        const arrayType = messages.filterTreeValidations.arrayType;
        const arrayLength = messages.filterTreeValidations.arrayLength;
        const comparisonOperatorType = messages.filterTreeValidations.comparisonOperatorType;
        const stringOperatorType = messages.filterTreeValidations.stringOperatorType;
        const setOperatorItems = messages.filterTreeValidations.setOperatorItems;
        const inOperatorItems = messages.filterTreeValidations.inOperatorItems;
        const matchesOperatorRequiredProperty = messages.filterTreeValidations.matchesOperatorRequiredProperty;
        const matchesOperatorIgnoreCase = messages.filterTreeValidations.matchesOperatorIgnoreCase;
        const matchesOperatorSpecItems = messages.filterTreeValidations.matchesOperatorSpecItems;
        const regexNotAllowed = messages.filterTreeValidations.regexNotAllowed;
        const objectTypeErrors = (operatorName, value) => {
            if (value === undefined) {
                return [];
            }
            if (isObject(value)) {
                return [];
            }
            return [objectType(operatorName, value)];
        };
        const arrayContainsNonObjectsErrors = (operatorName, value) => {
            if (!isArray(value)) {
                return [];
            }
            return value.flatMap((v) => objectTypeErrors(operatorName, v));
        };
        const nonArrayErrors = (operatorName, value) => {
            if (value === undefined) {
                return [];
            }
            if (isArray(value)) {
                return [];
            }
            return [arrayType(operatorName, value)];
        };
        const comparisonInvalidErrors = (operatorName, value) => {
            if (value === undefined) {
                return [];
            }
            if (isString(value) || isNumber(value) || isDate(value)) {
                return [];
            }
            return [comparisonOperatorType(operatorName, value)];
        };
        const nonStringOperatorErrors = (operatorName, value) => {
            if (value === undefined) {
                return [];
            }
            if (isString(value)) {
                return [];
            }
            return [stringOperatorType(operatorName, value)];
        };
        const nonSetOperatorErrors = (operatorName, value) => {
            const isSetOperator = (elem) => isDate(elem) || isString(elem) || isNumber(elem);
            if (!isArray(value)) {
                return [];
            }
            if (value.every(isSetOperator)) {
                return [];
            }
            return [setOperatorItems(operatorName, value)];
        };
        const arrayLengthErrors = (operatorName, value, expectedLength) => {
            if (!isArray(value)) {
                return [];
            }
            if (value.length === expectedLength) {
                return [];
            }
            return [arrayLength(operatorName, expectedLength, value)];
        };
        const inOperatorItemErrors = (value) => {
            if (!isArray(value)) {
                return [];
            }
            if (value.length !== 2) {
                return [];
            }
            if (isString(value[0]) && isNumber(value[1])) {
                return [];
            }
            return [inOperatorItems(value)];
        };
        const matchesValidationErrors = (value) => {
            const isValidSpec = (spec) => {
                if (!isObject(spec)) {
                    return false;
                }
                if (spec.type === 'anyOf' && spec.value === ' \t\n-') {
                    return true;
                }
                if (spec.type === 'literal' && isString(spec.value)) {
                    return true;
                }
                return false;
            };
            if (!isObject(value)) {
                return [];
            }
            if (value.ignoreCase === undefined) {
                return [matchesOperatorRequiredProperty('ignoreCase', value)];
            }
            if (value.ignoreCase !== true) {
                return [matchesOperatorIgnoreCase(value.ignoreCase)];
            }
            if (value.spec === undefined) {
                return [matchesOperatorRequiredProperty('spec', value)];
            }
            if (!isArray(value.spec)) {
                return [arrayType('$matches.spec', value.spec)];
            }
            const invalidSpec = value.spec.find((spec) => !isValidSpec(spec));
            if (invalidSpec !== undefined) {
                return [matchesOperatorSpecItems(invalidSpec)];
            }
            return [];
        };
        const regexNotAllowedErrors = (value) => {
            if (value === undefined) {
                return [];
            }
            return [regexNotAllowed()];
        };
        const getErrors = (filterRecords) => {
            if (!isObject(filterRecords)) {
                return [];
            }
            const { $and, $or, $not, $gt, $gte, $lt, $lte, $startsWith, $endsWith, $contains, $hasSome, $hasAll, $in, $matches, $regex, ...restOfFilter } = filterRecords;
            let errors = []
                .concat(nonArrayErrors('$and', $and))
                .concat(arrayContainsNonObjectsErrors('Filter Model', $and))
                .concat(nonArrayErrors('$or', $or))
                .concat(arrayContainsNonObjectsErrors('Filter Model', $or))
                .concat(nonArrayErrors('$not', $not))
                .concat(arrayContainsNonObjectsErrors('Filter Model', $not))
                .concat(nonArrayErrors('$hasSome', $hasSome))
                .concat(nonArrayErrors('$hasAll', $hasAll))
                .concat(nonArrayErrors('$in', $in))
                .concat(nonSetOperatorErrors('$hasSome', $hasSome))
                .concat(nonSetOperatorErrors('$hasAll', $hasAll))
                .concat(comparisonInvalidErrors('$gt', $gt))
                .concat(comparisonInvalidErrors('$gte', $gte))
                .concat(comparisonInvalidErrors('$lt', $lt))
                .concat(comparisonInvalidErrors('$lte', $lte))
                .concat(nonStringOperatorErrors('$startsWith', $startsWith))
                .concat(nonStringOperatorErrors('$endsWith', $endsWith))
                .concat(nonStringOperatorErrors('$contains', $contains))
                .concat(arrayLengthErrors('$not', $not, 1))
                .concat(arrayLengthErrors('$in', $in, 2))
                .concat(inOperatorItemErrors($in))
                .concat(objectTypeErrors('$matches', $matches))
                .concat(matchesValidationErrors($matches))
                .concat(regexNotAllowedErrors($regex));
            if (errors.length) {
                return errors;
            }
            errors = []
                .concat($and ? $and.flatMap(getErrors) : [])
                .concat($or ? $or.flatMap(getErrors) : [])
                .concat($not ? $not.flatMap(getErrors) : []);
            if (errors.length) {
                return errors;
            }
            return Object.values(restOfFilter).flatMap(getErrors);
        };
        if ([null, undefined].includes(filter)) {
            return Promise.resolve();
        }
        else if (!isObject(filter)) {
            return Promise.reject(this._validationError(collectionName, [
                objectType('Filter Model', filter),
            ]));
        }
        const errors = getErrors(filter);
        return errors.length
            ? Promise.reject(this._validationError(collectionName, errors))
            : Promise.resolve();
    }
    _validationError(collectionName, invalidArguments) {
        return validationError(messages.queryValidations.queryInvalid(collectionName, invalidArguments));
    }
    _getAuthHeader() {
        return Promise.resolve(isProvider(this.authHeader) ? this.authHeader.get() : this.authHeader);
    }
    _get(path, body, options) {
        return this._call(path, body, true, options);
    }
    _post(path, body, options) {
        return this._call(path, body, false, options);
    }
    _call(path, body, preferGet, options) {
        return Promise.all([this._getGridAppId(), this._getAuthHeader()]).then(([gridAppId, authHeader]) => {
            const url = `${this.cloudDataUrl}${path}`;
            const callWithRetries = retriesLeft => {
                return this.traceWith('wix-data-api-call', { url })(() => {
                    const data = {
                        ...serializeDates(body),
                        environment: this.environment,
                        appId: gridAppId,
                    };
                    const headers = authHeader ? { authorization: authHeader } : {};
                    if (preferGet) {
                        // https://github.com/wix-private/server-infra/tree/master/framework/grpc/rest#complex-requests-messages-with-get-mappings
                        const getUrl = `${url}?.r=${base64url(data)}`;
                        // Min limit for URLs is 2,083 but not sure if HTTP client or browser will add i.e. http://
                        if (getUrl.length <= 2048) {
                            return this.httpClientProvider(options).get(getUrl, { headers, includeWixHeaders: true });
                        }
                    }
                    return this.httpClientProvider(options).post(url, data, { headers, includeWixHeaders: true });
                })
                    .catch(error => {
                    return this.traceWith('wix-data retry handler', { retriesLeft, httpStatus: error?.response?.status, error, isGetRequest: preferGet })(() => {
                        if (preferGet && retriesLeft > 0 && error?.response?.status === 503) {
                            return callWithRetries(retriesLeft - 1);
                        }
                        else {
                            return Promise.reject(error);
                        }
                    });
                });
            };
            return callWithRetries(2)
                .catch(handleJsonErrorResponse(this.traceWith))
                .then(handleJsonResponse(this.traceWith));
        });
    }
    _getGridAppId() {
        return Promise.resolve(isProvider(this.gridAppId) ? this.gridAppId.get() : this.gridAppId);
    }
    _traceWith(methodName, options) {
        return (fn) => this._getGridAppId().then((gridAppId) => {
            return this.traceWith(methodName, {
                gridAppId,
                environment: this.environment,
                ...options,
            })(fn);
        });
    }
}
function _flatOptions(options) {
    return {
        appOptions: options?.appOptions,
        suppressHooks: options?.suppressHooks,
        fields: options?.fields,
        consistentRead: options?.consistentRead,
        language: options?.language,
        includeReferencedItems: options?.includeReferences,
        ...(options?.showDrafts
            ? { publishPluginOptions: { includeDraftItems: true } }
            : {}),
    };
}
//# sourceMappingURL=platformized-data-provider.js.map