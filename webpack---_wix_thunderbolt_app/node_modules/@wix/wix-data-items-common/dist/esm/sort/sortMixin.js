import { clone, isString, isArray } from '../utils';
import { AggregatingValidator, messages, validationError } from '../errors';
const sortMixin = (Base = class {
}) => class extends Base {
    constructor(obj = {}) {
        super(obj);
        this.orderBy = obj.orderBy || [];
        this.invalidArguments = obj.invalidArguments || [];
    }
    ascending(...fields) {
        return this._sortClause('asc', '.ascending', fields);
    }
    descending(...fields) {
        return this._sortClause('desc', '.descending', fields);
    }
    getSortModel() {
        if (this.invalidArguments.length > 0) {
            throw validationError(messages.sortBuilderInvalid(this.invalidArguments));
        }
        return this.orderBy;
    }
    setSortModel(sortModel) {
        return this._copySort(sortModel, []);
    }
    _sortClause(operatorSymbol, operatorName, args) {
        let orderBy = [];
        if (this.orderBy) {
            orderBy = clone(this.orderBy);
        }
        const appendClause = createAppendClauseFn(orderBy, operatorSymbol);
        const effectiveArgs = isArray(args[0]) && args.length === 1
            ? args[0]
            : Array.prototype.slice.call(args, 0);
        const [newInvalidArguments, valid] = this._sortValidator(operatorName)
            .arityIsAtLeastOne(args)
            .allStrings(effectiveArgs)
            .validateAndAggregate();
        if (valid) {
            effectiveArgs.forEach(appendClause);
        }
        return this._copySort(orderBy, newInvalidArguments);
    }
    _sortValidator(operatorName) {
        return new SortValidator(operatorName, this.invalidArguments);
    }
    _copySort(orderBy, invalidArguments) {
        return new this.constructor({
            ...this,
            orderBy,
            invalidArguments,
        });
    }
};
function createAppendClauseFn(destination, direction) {
    return (field) => {
        const spec = { [field]: direction };
        destination.push(spec);
    };
}
export class SortValidator extends AggregatingValidator {
    constructor(operatorName, previousInvalidArguments) {
        super(previousInvalidArguments);
        this.operatorName = operatorName;
    }
    allStrings(effectiveArgs) {
        return this.addValidation(() => effectiveArgs.every(isString), () => {
            return messages.sortValidations.typeIsStringOrArrayOfStrings(this.operatorName, effectiveArgs);
        });
    }
}
export class Sort extends sortMixin() {
}
export default sortMixin;
//# sourceMappingURL=sortMixin.js.map