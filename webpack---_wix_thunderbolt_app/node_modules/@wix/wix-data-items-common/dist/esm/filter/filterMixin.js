import { typeForDisplay, isDate, isString, isNumber } from '../utils/type-utils';
import { AggregatingValidator } from '../errors/base-validator';
import { messages, validationError } from '../errors/errors';
import { filterMixin as genericFilterMixin, } from '@wix/filter-builder';
const filterMixin = (Base = class {
}) => class extends genericFilterMixin(Base) {
    constructor(origin) {
        super(origin);
        this.validateCollectionName = origin?.validateCollectionName ?? true;
    }
    or(otherQuery) {
        const orQuery = super.or.apply(this, arguments);
        return this._validateCollectionName(orQuery, otherQuery, '.or');
    }
    and(otherQuery) {
        const andQuery = super.and.apply(this, arguments);
        return this._validateCollectionName(andQuery, otherQuery, '.and');
    }
    not(otherQuery) {
        const notQuery = super.not.apply(this, arguments);
        return this._validateCollectionName(notQuery, otherQuery, '.not');
    }
    _validateCollectionName(query, originalQuery, operationName) {
        if (query.invalidArguments.length > 0 || !this.validateCollectionName) {
            return query;
        }
        const withCollectionName = withCollectionNameIfUnset(originalQuery, this.collectionName);
        const [newInvalidArguments, valid] = new FilterValidator(operationName, query.invalidArguments, this.constructor, this.constructorName ?? this.constructor.name)
            .isForCollection(withCollectionName, this.collectionName)
            .validateAndAggregate();
        if (!valid) {
            return this._copy(this.filterTree, newInvalidArguments);
        }
        return query;
    }
    // used only from data binding router internally
    _matchesUrlized(field, operand) {
        const [newInvalidArguments, valid] = this._filterValidator('._matchesUrlized')
            .arityIsTwo(arguments)
            .validFieldName(field)
            .typeIsString(operand)
            .validateAndAggregate();
        if (valid) {
            const newFilterTree = this._makeNewFilter(field, 
            // @ts-ignore-next-line
            ...createMatchesOrInFilter(operand));
            return this._copy(newFilterTree, newInvalidArguments);
        }
        return this._copy(this.filterTree, newInvalidArguments);
    }
    getFilterModel() {
        if (this.invalidArguments.length > 0) {
            throw validationError(messages.filterBuilderInvalid(this.invalidArguments));
        }
        return super.getFilterModel();
    }
    _filterValidator(filterOperatorName) {
        return new FilterValidator(filterOperatorName, this.invalidArguments, this.constructor, this.constructorName ?? this.constructor.name);
    }
};
function createMatchesOrInFilter(operand) {
    if (looksLikeAnInteger(operand)) {
        // eslint-disable-next-line radix
        return ['$in', [operand, Number.parseInt(operand)]];
    }
    else {
        return [
            '$matches',
            {
                ignoreCase: true,
                spec: createMatchSpec(operand),
            },
        ];
    }
    function looksLikeAnInteger(str) {
        return /^-?[0-9]{1,16}$/.test(str);
    }
}
function createMatchSpec(fieldValue) {
    const literals = fieldValue.split('-');
    const result = [];
    for (let i = 0; i < literals.length - 1; i++) {
        appendLiteralSegment(result, literals[i]);
        appendAnyOfSegment(result);
    }
    appendLiteralSegment(result, literals[literals.length - 1]);
    return result;
    function appendLiteralSegment(res, literalValue) {
        if (literalValue.length !== 0) {
            res.push({ type: 'literal', value: literalValue });
        }
    }
    function appendAnyOfSegment(res) {
        res.push({ type: 'anyOf', value: ' \t\n-' });
    }
}
export class FilterValidator extends AggregatingValidator {
    constructor(operatorName, previousInvalidArguments, ctor, constructorName) {
        super(previousInvalidArguments);
        this.operatorName = operatorName;
        this.ctor = ctor;
        this.constructorName = constructorName;
    }
    typeIsString(value) {
        return this.addValidation(() => isString(value), () => messages.filterValidations.typeIsString(this.operatorName, value));
    }
    typeIsStringNumberOrDate(value) {
        return this.addValidation(() => isDateStringOrNumber(value), () => messages.filterValidations.typeIsStringNumberOrDate(this.operatorName, value));
    }
    sameType(first, second) {
        return this.addValidation(() => typeForDisplay(first) === typeForDisplay(second), () => messages.filterValidations.sameType(this.operatorName, first, second));
    }
    typeIsStringNumberOrDateForAll(values) {
        return this.addValidation(() => values.every(isDateStringOrNumber), () => messages.filterValidations.typeIsStringNumberOrDateForAll(this.operatorName));
    }
    validFieldName(field) {
        return this.addValidation(() => isString(field), () => messages.filterValidations.validFieldName(this.operatorName, field));
    }
    isInstanceOfSameClass(obj) {
        return this.addValidation(() => obj instanceof this.ctor, () => messages.filterValidations.isInstanceOfSameClass(this.operatorName, this.constructorName, obj));
    }
    isForCollection(otherFilterBuilder, expectedCollectionName) {
        return this.addValidation(() => otherFilterBuilder.collectionName === expectedCollectionName, () => messages.filterValidations.isForCollection(this.operatorName, this.constructorName, otherFilterBuilder.collectionName));
    }
}
function isDateStringOrNumber(value) {
    return isString(value) || isNumber(value) || isDate(value);
}
function withCollectionNameIfUnset(filter, name) {
    if (!filter || !filter.constructor) {
        return filter;
    }
    const collectionName = filter.collectionName ? filter.collectionName : name;
    return new filter.constructor({ ...filter, collectionName });
}
export default filterMixin;
//# sourceMappingURL=filterMixin.js.map