import { typeForDisplay } from '../utils/type-utils';
import safeJsonStringify from 'safe-json-stringify';
// When adding new messages, update Support article with error code and explanation about the error.
export const messages = {
    collectionNameMustBeAString: () => 'WDE0001: Collection name must be a string.',
    itemIdMustBeAString: () => 'WDE0002: ItemId must be a string.',
    itemIdsMustBeArrayOfStrings: () => 'WDE0068: Item ids must be an array of strings',
    removeItemsMustBeLessThanThousand: (collectionName) => `WDE0069: Failed to remove items from [${collectionName}].\nCannot remove more than 1000 items in one request`,
    fieldNameMustBeAString: () => 'WDE0003: FieldName must be a string.',
    itemMustBeAnObject: (item, collectionName) => `WDE0004: Failed to save [${item}] into [${collectionName}].\nItems must be JavaScript objects.`,
    itemsMustBeArrayOfObjects: (collectionName) => `WDE0005: Failed to bulk save items into [${collectionName}].\nItems must be an array of JavaScript objects and itemIds must be strings if present.`,
    itemsMustBeLessThanThousand: (collectionName) => `WDE0006: Failed to bulk save items into [${collectionName}].\nCannot insert more than 1000 items in one request`,
    updateItemInvalid: () => 'WDE0007: Invalid update. Updated object must have a string _id property.',
    invalidArgumentLength: (method, from, to, actual) => `WDE0008: wixData.${method} expects between ${from} and ${to} arguments, but was called with ${actual}.`,
    aggregateValidations: {
        aggregateInvalid: (collectionName, invalidArguments) => `Failed to perform aggregation on [${collectionName}].\n${invalidArguments.join('\n')}`,
        filterMustBeBuilder: (operatorName) => `WDE0011: Invalid ${operatorName} usage. ${operatorName} requires WixDataFilter.`,
        filterIsAlreadySet: (operatorName) => `WDE0012: Invalid ${operatorName} usage. Filter is already set.`,
        groupIsAlreadySet: (operatorName) => `WDE0013: Invalid ${operatorName} usage. Group is already set.`,
    },
    filterBuilderInvalid: (invalidArguments) => `Failed to build a filter.\n${invalidArguments.join('\n')}.`,
    groupBuilderInvalid: (invalidArguments) => `Failed to build group.\n${invalidArguments.join('\n')}.`,
    filterMustBeAnObject: () => 'WDE0016: Filter must be an object.',
    sortBuilderInvalid: (invalidArguments) => `Failed to build a sort.\n${invalidArguments.join('\n')}.`,
    optionsInvalid: (properties) => `WDE0018: Options must be an object with one or all of the following boolean properties: ${properties.join(', ')}.`,
    referenceOperationParameterError: () => 'WDE0019: Reference operation takes a string ID or an object with an ID to be connected.',
    referenceOperationFieldError: (fieldName) => `WDE0020: Provided property [${fieldName}] is not a multi-reference field.`,
    invalidReferenceError: () => `WDE0021: Invalid reference`,
    queryValidations: {
        queryInvalid: (collectionName, invalidArguments) => `Failed to perform query on [${collectionName}].\n${invalidArguments.join('\n')}`,
        isNumber: (operatorName, specifier, operand) => `WDE0032: Invalid ${operatorName} parameter [${typeForDisplay(operand)}]. ${operatorName} parameter must be a ${specifier} number.`,
        isPositiveNumber: (operatorName, operand) => `WDE0033: Invalid ${operatorName} parameter [${operand}]. ${operatorName} parameter must be a positive number.`,
        isNonNegativeNumber: (operatorName, operand) => `WDE0034: Invalid ${operatorName} parameter [${operand}]. ${operatorName} parameter must be a non-negative number.`,
        isInteger: (operatorName, operand) => `WDE0035: Invalid ${operatorName} parameter [${operand}]. ${operatorName} parameter must be an integer.`,
        isNonEmptyString: (operatorName) => `WDE0094: Invalid ${operatorName} parameter. ${operatorName} parameter must be non-empty string.`,
        notGreaterThan: (operatorName, operand, value) => `WDE0036: Invalid ${operatorName} parameter [${operand}]. ${operatorName} parameter cannot exceed ${value}.`,
        invalidSkipParameter: (collectionName, skipParameter) => `WDE0037: Invalid query on [${collectionName}].\nInvalid prev positioned query skip on a negative number ${skipParameter}.`,
        noPrevPage: (collectionName) => `WDE0159: Invalid query on [${collectionName}].\nThere is no prev page.`,
        noNextPage: (collectionName) => `WDE0165: Invalid query on [${collectionName}].\nThere is no next page.`,
    },
    arityValidations: {
        arityIsZero: (operatorName) => `WDE0038: Invalid ${operatorName} usage. ${operatorName} does not take parameters.`,
        arityIsOne: (operatorName) => `WDE0039: Invalid ${operatorName} usage. ${operatorName} requires one parameter.`,
        arityIsTwo: (operatorName) => `WDE0040: Invalid ${operatorName} usage. ${operatorName} requires two parameters.`,
        arityIsThree: (operatorName) => `WDE0041: Invalid ${operatorName} usage. ${operatorName} requires three parameters.`,
        arityIsAtLeastTwo: (operatorName) => `WDE0042: Invalid ${operatorName} usage. ${operatorName} requires at least two parameters.`,
        arityIsAtLeastOne: (operatorName) => `WDE0043: Invalid ${operatorName} usage. ${operatorName} requires at least one parameter.`,
    },
    filterValidations: {
        typeIsString: (operatorName, value) => `WDE0044: Invalid ${operatorName} parameter value [${typeForDisplay(value)}]. ${operatorName} parameter must be a String.`,
        typeIsStringNumberOrDate: (operatorName, value) => `WDE0045: Invalid ${operatorName} parameter value [${typeForDisplay(value)}]. Valid ${operatorName} parameter types are String, Number or Date.`,
        sameType: (operatorName, first, second) => `WDE0046: Invalid ${operatorName} parameter values [${typeForDisplay(first)}] and [${typeForDisplay(second)}]. Both parameters must be of the same type.`,
        typeIsStringNumberOrDateForAll: (operatorName) => `WDE0047: Invalid ${operatorName} usage. ${operatorName} supports only Number, String or Date items.`,
        validFieldName: (operatorName, field) => `WDE0048: Invalid ${operatorName} field value [${typeForDisplay(field)}]. ${operatorName} field must be a String.`,
        isInstanceOfSameClass: (operatorName, constructorName, obj) => `WDE0049: Invalid ${operatorName} parameter [${typeForDisplay(obj)}]. ${operatorName} expects ${constructorName} only.`,
        isForCollection: (operatorName, constructorName, collectionName) => `WDE0050: Invalid ${operatorName} parameter query for [${collectionName}]. ${operatorName} accepts ${constructorName} for the same collection only.`,
    },
    filterTreeValidations: {
        objectType: (operatorName, value) => `WDE0056: ${operatorName} should be an Object. Got ${stringify(value)} instead`,
        arrayType: (operatorName, value) => `WDE0057: ${operatorName} should be an Array. Got ${stringify(value)} instead`,
        arrayLength: (operatorName, expectedLength, value) => `WDE0057: ${stringify(value)}.length is ${value.length}. ${operatorName} Array should have length ${expectedLength}`,
        comparisonOperatorType: (operatorName, value) => `WDE0058: ${operatorName} should be a Date, Number, or String. Got ${stringify(value)} instead`,
        stringOperatorType: (operatorName, value) => `WDE0059: ${operatorName} should be a String. Got ${stringify(value)} instead`,
        setOperatorItems: (operatorName, value) => `WDE0060: ${operatorName} Array should only contain values of types Date, Number, and String. Got ${stringify(value)} instead`,
        inOperatorItems: (value) => `WDE0061: $in Array should have length 2, and match [String, Number]. Got ${stringify(value)} instead`,
        matchesOperatorRequiredProperty: (propertyName, value) => `WDE0062: $matches value ${stringify(value)} does not have property ${propertyName}`,
        matchesOperatorIgnoreCase: (value) => `WDE0063: $matches.ignoreCase should equal true. Got ${stringify(value)} instead`,
        matchesOperatorSpecItems: (value) => `WDE0064: $matches.spec Array values should be either {"type":"anyOf","value":" -"} or {"type":"literal","value":String}. Got ${stringify(value)} instead`,
        regexNotAllowed: () => 'WDE0070: $regex keyword is not allowed.',
    },
    sortValidations: {
        typeIsStringOrArrayOfStrings: (operatorName, effectiveArgs) => `WDE0051: Invalid ${operatorName} parameters [${effectiveArgs.map(typeForDisplay)}]. Valid ${operatorName} values are String, Array of String or varargs String.`,
    },
    orderByValidations: {
        sortModelType: (value) => `WDE0065: Sort Model should be an Array. Got ${stringify(value)} instead`,
        sortModelItemType: (value) => `WDE0066: Sort Model Array should contain values of type Object only. Got ${stringify(value)} instead`,
        sortModelItem: (value) => `WDE0067: Sort Model Array items should have a single property with value "asc" or "desc". Got ${stringify(value)} instead`,
    },
    internalError: (message) => `WDE0053: Internal wixData error: ${message}`,
    serverInvalidResponse: (message) => 'WDE0055: Failed to parse server response.' +
        (message ? ` ${message}` : ''),
    itemDoesNotExist: (id, collectionName) => `WDE0073: Item [${id}] does not exist in collection [${collectionName}].`,
    cursorPagingDoesNotSupportSkip: () => 'WDE0080: Skip is not supported in cursor paging.',
    payloadIsTooLarge: () => 'WDE0109: Payload is too large.',
};
function stringify(obj) {
    return safeJsonStringify(obj);
}
export const codes = {
    ItemDoesNotExist: 'WD_ITEM_DOES_NOT_EXIST',
    ItemAlreadyExists: 'WD_ITEM_ALREADY_EXISTS',
    SiteInTemplateMode: 'WD_SITE_IN_TEMPLATE_MODE',
    UnknownError: 'WD_UNKNOWN_ERROR',
    ValidationError: 'WD_VALIDATION_ERROR',
    CollectionDeleted: 'WD_COLLECTION_DELETED',
    SchemaDoesNotExist: 'WD_SCHEMA_DOES_NOT_EXIST',
    PermissionDenied: 'WD_PERMISSION_DENIED',
    BadRequest: 'WD_BAD_REQUEST',
    Unauthorized: 'WD_UNAUTHORIZED',
    TooManyRequests: 'WD_TOO_MANY_REQUESTS',
    RequestTimedOut: 'WD_REQUEST_TIMED_OUT',
    QuotaExceeded: 'WD_DATABASE_QUOTA_EXCEEDED',
    QueryExecutionError: 'WD_QUERY_EXECUTION_ERROR',
};
export function wixDataError(message, code, details) {
    return errorWithCode(message, code, details);
}
export function validationError(message) {
    return errorWithCode(message, codes.ValidationError);
}
function errorWithCode(message, code, details) {
    const ErrorConstructor = code && code !== codes.UnknownError ? WixDataError : Error;
    // @ts-ignore-next-line
    const error = new ErrorConstructor(message);
    // @ts-ignore-next-line
    error.code = code;
    if (details) {
        // @ts-ignore-next-line
        error.details = details;
    }
    return error;
}
class WixDataError extends Error {
    constructor(message) {
        super(message);
        this.name = 'Error';
        // marker for user error
        this.errorGroup = 'User';
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, WixDataError);
        }
    }
}
export class BulkError extends Error {
    constructor(message, code, item, name, originalIndex) {
        super(message);
        this.message = message;
        this.code = code;
        this.item = item;
        this.name = name;
        this.originalIndex = originalIndex;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, BulkError);
        }
    }
}
//# sourceMappingURL=errors.js.map