/* eslint-disable  @typescript-eslint/no-explicit-any */
import { clone } from '../utils/clone';
import { messages, validationError } from './errors';
class BaseValidator {
    constructor() {
        this._validations = [];
    }
    arityIsZero(args) {
        return this.addValidation(() => args.length === 0, () => messages.arityValidations.arityIsZero(this.operatorName ?? ''));
    }
    arityIsOne(args) {
        return this.addValidation(() => args.length === 1, () => messages.arityValidations.arityIsOne(this.operatorName ?? ''));
    }
    arityIsTwo(args) {
        return this.addValidation(() => args.length === 2, () => messages.arityValidations.arityIsTwo(this.operatorName ?? ''));
    }
    arityIsThree(args) {
        return this.addValidation(() => args.length === 3, () => messages.arityValidations.arityIsThree(this.operatorName ?? ''));
    }
    arityIsAtLeastTwo(args) {
        return this.addValidation(() => args.length >= 2, () => messages.arityValidations.arityIsAtLeastTwo(this.operatorName ?? ''));
    }
    arityIsAtLeastOne(args) {
        return this.addValidation(() => args.length >= 1, () => messages.arityValidations.arityIsAtLeastOne(this.operatorName ?? ''));
    }
    addValidation(predicateFn, messageFn) {
        this._validations.push({
            predicateFn,
            messageFn,
        });
        return this;
    }
}
export class AggregatingValidator extends BaseValidator {
    constructor(previousInvalidArguments) {
        super();
        this._invalidArguments = clone(previousInvalidArguments);
    }
    validateAndAggregate() {
        const valid = this._validations.every(({ predicateFn, messageFn }) => this._appendIfInvalid(predicateFn(), messageFn()));
        return [this._invalidArguments, valid];
    }
    _appendIfInvalid(valid, message) {
        if (!valid) {
            this._invalidArguments.push(message);
            return false;
        }
        return true;
    }
}
export class RejectingValidator extends BaseValidator {
    validateAndReject() {
        return Promise.resolve().then(() => {
            this._validations.forEach(({ predicateFn, messageFn }) => {
                if (!predicateFn()) {
                    throw validationError(messageFn());
                }
            });
        });
    }
    validateAndReturn() {
        const errors = [];
        this._validations.forEach(({ predicateFn, messageFn }) => {
            if (!predicateFn()) {
                errors.push(messageFn());
            }
        });
        return errors;
    }
}
//# sourceMappingURL=base-validator.js.map