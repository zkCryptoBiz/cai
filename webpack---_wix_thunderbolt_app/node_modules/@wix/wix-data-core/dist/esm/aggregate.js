import { sortMixin } from '@wix/wix-data-items-common';
import { AggregatingValidator, messages, validationError, apiValidator, } from '@wix/wix-data-errors';
import { groupMixin, formId } from './group';
import { clone, isNumber, isObject, isString } from '@wix/wix-data-utils';
import { isCursorDefined } from './paging/cursors';
import { calcSkipNumber } from './utils/skip-calculator';
export class WixDataAggregate extends sortMixin(groupMixin()) {
    constructor(obj = {}) {
        super(obj);
        this.provider = obj.provider;
        this.collectionName = obj.collectionName;
        this.filterTree = obj.filterTree;
        this.havingTree = obj.havingTree;
        this.skipNumber = obj.skipNumber || 0;
        this.limitNumber = obj.limitNumber;
        this.cursor = obj.cursor;
        this.invalidArguments = obj.invalidArguments || [];
    }
    filter(filter) {
        const [newInvalidArguments] = this._aggregateValidator('.filter')
            .arityIsOne(arguments)
            .filterIsNotSet(this)
            .filterBuilder(filter)
            .validateAndAggregate();
        return new WixDataAggregate({
            provider: this.provider,
            collectionName: this.collectionName,
            filterTree: filter.filterTree,
            groupByTree: this.groupByTree,
            havingTree: this.havingTree,
            skipNumber: this.skipNumber,
            limitNumber: this.limitNumber,
            cursor: this.cursor,
            orderBy: this.orderBy,
            invalidArguments: newInvalidArguments.concat(filter.invalidArguments),
        });
    }
    group(...fieldName) {
        let groupByTree = clone(this.groupByTree);
        const [newInvalidArguments] = this._aggregateValidator('.group')
            .arityIsAtLeastOne(arguments)
            .groupIsNotSet(groupByTree)
            .validateAndAggregate();
        if (!groupByTree) {
            groupByTree = { _id: formId(...fieldName) };
        }
        else if (groupByTree._id === '0') {
            groupByTree = { ...groupByTree, _id: formId(...fieldName) };
        }
        return new WixDataAggregate({
            provider: this.provider,
            collectionName: this.collectionName,
            filterTree: this.filterTree,
            groupByTree,
            havingTree: this.havingTree,
            skipNumber: this.skipNumber,
            limitNumber: this.limitNumber,
            cursor: this.cursor,
            orderBy: this.orderBy,
            invalidArguments: newInvalidArguments,
        });
    }
    having(filter) {
        const [newInvalidArguments] = this._aggregateValidator('.having')
            .arityIsOne(arguments)
            .havingIsNotSet(this)
            .filterBuilder(filter)
            .validateAndAggregate();
        return new WixDataAggregate({
            provider: this.provider,
            collectionName: this.collectionName,
            filterTree: this.filterTree,
            groupByTree: this.groupByTree,
            havingTree: filter.filterTree,
            skipNumber: this.skipNumber,
            limitNumber: this.limitNumber,
            cursor: this.cursor,
            orderBy: this.orderBy,
            invalidArguments: newInvalidArguments.concat(filter.invalidArguments),
        });
    }
    skip(skipNumber) {
        const [newInvalidArguments] = this._aggregateValidator('.skip')
            .arityIsOne(arguments)
            .isNonNegativeNumber(skipNumber)
            .isInteger(skipNumber)
            .validateAndAggregate();
        return new WixDataAggregate({
            provider: this.provider,
            collectionName: this.collectionName,
            filterTree: this.filterTree,
            groupByTree: this.groupByTree,
            havingTree: this.havingTree,
            skipNumber,
            limitNumber: this.limitNumber,
            cursor: this.cursor,
            orderBy: this.orderBy,
            invalidArguments: newInvalidArguments,
        });
    }
    limit(limitNumber) {
        const [newInvalidArguments] = this._aggregateValidator('.limit')
            .arityIsOne(arguments)
            .isPositiveNumber(limitNumber)
            .isInteger(limitNumber)
            .validateAndAggregate();
        return new WixDataAggregate({
            provider: this.provider,
            collectionName: this.collectionName,
            filterTree: this.filterTree,
            groupByTree: this.groupByTree,
            havingTree: this.havingTree,
            skipNumber: this.skipNumber,
            limitNumber,
            cursor: this.cursor,
            orderBy: this.orderBy,
            invalidArguments: newInvalidArguments,
        });
    }
    run(options) {
        const self = this;
        const pipeline = this._buildPipeline();
        return rejectIfInvalid(this.invalidArguments, this.collectionName)
            .then(() => apiValidator().options(options).validateAndReject())
            .then(() => this.provider.runAggregate(this.collectionName, pipeline, this.limitNumber, options, this.cursor))
            .then(({ items, hasNext, cursors }) => {
            return new WixDataAggregateResult({
                items,
                hasNext,
                aggregate: self,
                pageSize: items.length,
                cursors,
                createdByCursor: this.cursor,
            });
        });
    }
    _buildPipeline() {
        return [
            this.filterTree ? { $match: this.filterTree } : null,
            this.groupByTree ? { $group: this.groupByTree } : null,
            this.groupByTree
                ? { $project: buildProjectStage(this.groupByTree) }
                : null,
            this.havingTree ? { $match: this.havingTree } : null,
            this.orderBy.length > 0 ? { $sort: this.orderBy } : null,
            { $skip: this.skipNumber },
        ].filter((stage) => stage !== null);
    }
    _aggregateValidator(operatorName) {
        return new AggregationValidator(operatorName, this.invalidArguments);
    }
}
function rejectIfInvalid(invalidArguments, collectionName) {
    if (invalidArguments.length > 0) {
        return Promise.reject(validationError(messages.aggregateValidations.aggregateInvalid(collectionName, invalidArguments)));
    }
    else {
        return Promise.resolve();
    }
}
function buildProjectStage(groupByTree) {
    const keys = Object.keys(groupByTree);
    const fields = keys.map((key) => ({
        [key]: 1,
    }));
    if (isObject(groupByTree._id)) {
        fields.push(projectId(groupByTree._id));
    }
    else if (isString(groupByTree._id) && groupByTree._id !== '0') {
        fields.push({ [groupByTree._id.substr(1)]: '$_id' });
    }
    return Object.assign({}, ...fields);
}
function projectId(idField) {
    const keys = Object.keys(idField);
    const fields = keys.map((key) => ({ [key]: `$_id.${key}` }));
    return Object.assign({}, ...fields);
}
export function aggregateFactory(provider, collectionName) {
    return new WixDataAggregate({ provider, collectionName });
}
export function aggregateFetchFactory(provider, collectionName, limit, cursor) {
    return new WixDataAggregate({
        provider,
        collectionName,
        cursor,
        limitNumber: limit,
    });
}
export class WixDataAggregateResult {
    constructor(obj) {
        if (!obj) {
            return;
        }
        this._items = obj.items;
        this._hasNext = obj.hasNext;
        this._aggregate = obj.aggregate;
        this._pageSize = obj.pageSize;
        this._cursors = obj.cursors;
        this._createdByCursor = obj.createdByCursor;
    }
    get items() {
        return this._items;
    }
    hasNext() {
        return this._hasNext;
    }
    hasPrev() {
        if (isCursorDefined(this._createdByCursor) || this._cursors) {
            return isCursorDefined(this.prevCursor);
        }
        else {
            return this._aggregate.skipNumber > 0;
        }
    }
    get length() {
        return this._items.length;
    }
    next() {
        if (!this.hasNext()) {
            return this._rejectNoNextPage();
        }
        let nextAggregate;
        if (isCursorDefined(this.nextCursor)) {
            nextAggregate = this._getNewCursorAggregate(this.nextCursor);
        }
        else {
            const skipNumber = calcSkipNumber(this._aggregate, this.length, true);
            nextAggregate = this._aggregate.skip(skipNumber);
        }
        return nextAggregate.run();
    }
    prev() {
        if (!this.hasPrev()) {
            return this._rejectNoPrevPage();
        }
        let prevAggregate;
        if (isCursorDefined(this.prevCursor)) {
            prevAggregate = this._getNewCursorAggregate(this.prevCursor);
        }
        else {
            prevAggregate = this._aggregate.skip(Math.max(0, this._aggregate.skipNumber - this._aggregate.limitNumber));
        }
        return prevAggregate.run();
    }
    get nextCursor() {
        return this._cursors && this._cursors.next;
    }
    get prevCursor() {
        return this._cursors && this._cursors.prev;
    }
    _getNewCursorAggregate(cursor) {
        const aggregate = this._aggregate;
        return aggregateFetchFactory(aggregate.provider, aggregate.collectionName, aggregate.limitNumber, cursor);
    }
    _rejectNoPrevPage() {
        return Promise.reject(validationError(messages.queryValidations.noPrevPage(this._aggregate.collectionName)));
    }
    _rejectNoNextPage() {
        return Promise.reject(validationError(messages.queryValidations.noNextPage(this._aggregate.collectionName)));
    }
}
const MAX_SAFE_INTEGER = 9007199254740991;
class AggregationValidator extends AggregatingValidator {
    constructor(operatorName, previousInvalidArguments) {
        super(previousInvalidArguments);
        this.operatorName = operatorName;
    }
    filterBuilder(filter) {
        return this.addValidation(() => filter.constructorName === 'FilterBuilder', () => messages.aggregateValidations.filterMustBeBuilder(this.operatorName));
    }
    filterIsNotSet(aggregate) {
        return this.addValidation(() => aggregate.filterTree === undefined, () => messages.aggregateValidations.filterIsAlreadySet(this.operatorName));
    }
    havingIsNotSet(aggregate) {
        return this.addValidation(() => aggregate.havingTree === undefined, () => messages.aggregateValidations.filterIsAlreadySet(this.operatorName));
    }
    groupIsNotSet(groupByTree) {
        return this.addValidation(() => groupIsNotSet(groupByTree), () => messages.aggregateValidations.groupIsAlreadySet(this.operatorName));
    }
    _isNumber(specifier, operand) {
        return this.addValidation(() => isNumber(operand), () => messages.queryValidations.isNumber(this.operatorName, specifier, operand));
    }
    isPositiveNumber(operand) {
        return this._isNumber('positive', operand).addValidation(() => !Number.isNaN(operand) && operand > 0, () => messages.queryValidations.isPositiveNumber(this.operatorName, operand));
    }
    isNonNegativeNumber(operand) {
        return this._isNumber('non-negative', operand).addValidation(() => !Number.isNaN(operand) && operand >= 0, () => messages.queryValidations.isNonNegativeNumber(this.operatorName, operand));
    }
    isInteger(operand) {
        return this.addValidation(() => !Number.isNaN(operand) &&
            Number.isFinite(operand) &&
            Number.isInteger(operand) &&
            operand < MAX_SAFE_INTEGER &&
            operand > -MAX_SAFE_INTEGER, () => messages.queryValidations.isInteger(this.operatorName, operand));
    }
}
function groupIsNotSet(groupByTree) {
    return groupByTree ? groupByTree._id === '0' : true;
}
//# sourceMappingURL=aggregate.js.map