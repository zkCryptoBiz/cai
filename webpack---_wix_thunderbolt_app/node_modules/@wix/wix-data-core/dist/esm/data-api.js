import { queryFactory } from './query';
import { groupFactory } from './group';
import { aggregateFactory, aggregateFetchFactory, } from './aggregate';
import { filterBuilderFactory } from '@wix/wix-data-items-common';
import { sortBuilderFactory } from './sort/sortBuilder';
import { apiValidator, BulkError } from '@wix/wix-data-errors';
import { isObject, isArray } from '@wix/wix-data-utils';
import { referenceResultFactory } from './multiref';
import { hasField } from './utils/field-key-utils';
export default class WixDataApi {
    constructor(provider) {
        this.get = withArgs((args, collectionName, itemId, options) => apiValidator()
            .arity('get', args, 2, 3)
            .collectionName(collectionName)
            .itemId(itemId)
            .options(options)
            .validateAndReject()
            .then(() => this.provider.get(collectionName, itemId, options))
            .then(passOrWrap));
        this.insert = withArgs((args, collectionName, item, options) => apiValidator()
            .arity('insert', args, 2, 3)
            .validateAndReject()
            .then(() => mutate(this.provider, 'insert')(collectionName, item, options)));
        this.query = (collectionName) => queryFactory(this.provider, collectionName);
        this.filter = () => filterBuilderFactory();
        this.sort = () => sortBuilderFactory();
        this.find = (collectionName, filter, order, skip, limit, options, includes, omitTotalCount) => {
            const query = queryFactory(this.provider, collectionName);
            query.filterTree = filter;
            query.orderBy = order;
            query.skipNumber = skip;
            query.limitNumber = limit;
            query.included = includes;
            const adjustedOptions = { ...options, omitTotalCount };
            return query.find(adjustedOptions);
        };
        this.remove = withArgs((args, collectionName, itemId, options) => apiValidator()
            .arity('remove', args, 2, 3)
            .collectionName(collectionName)
            .itemId(itemId)
            .options(options)
            .validateAndReject()
            .then(() => this.provider.remove(collectionName, itemId, options))
            .then(passOrWrap));
        this.truncate = withArgs((args, collectionName, options) => apiValidator()
            .arity('truncate', args, 1, 2)
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => this.provider.truncate(collectionName, options))
            .then(passOrWrap));
        this.bulkRemove = withArgs((args, collectionName, itemIds, options) => apiValidator()
            .arity('bulkRemove', args, 2, 3)
            .collectionName(collectionName)
            .itemIds(itemIds, collectionName)
            .options(options)
            .validateAndReject()
            .then(() => this.provider.bulkRemove(collectionName, itemIds, options))
            .then(passOrWrap)
            .then((bulkResult) => {
            const errors = bulkResult.errors.map((err) => new BulkError(err.message, err.code, err.item, err.name, err.originalIndex));
            return { ...bulkResult, errors };
        }));
        this.save = withArgs((args, collectionName, item, options) => apiValidator()
            .arity('save', args, 2, 3)
            .validateAndReject()
            .then(() => mutate(this.provider, 'save')(collectionName, item, options)));
        this.update = withArgs((args, collectionName, item, options) => apiValidator()
            .arity('update', args, 2, 3)
            .validateAndReject()
            .then(() => mutate(this.provider, 'update')(collectionName, item, options)));
        this.fetch = withArgs((args, collectionName, cursor, limit, options) => apiValidator()
            .arity('fetch', args, 3, 4)
            .isNonEmptyString(cursor, 'cursor')
            .validateAndReject()
            .then(() => {
            const query = queryFactory(this.provider, collectionName).limit(limit);
            query.cursor = cursor;
            query.included = undefined;
            query.projectedFields = undefined;
            query.filterTree = undefined;
            query.skipNumber = undefined;
            return query.find(options);
        }));
        this.fetchReferenced = withArgs((args, collectionName, cursor, limit, options) => apiValidator()
            .arity('fetchReferenced', args, 3, 4)
            .isNonEmptyString(cursor, 'cursor')
            .validateAndReject()
            .then(() => {
            const safeOptions = { ...options };
            safeOptions.limit = limit;
            safeOptions.cursor = cursor;
            safeOptions.omitTotalCount = true; // Total count must be omitted for cursored requests
            return this.provider
                .queryReferenced(collectionName, undefined, undefined, safeOptions)
                .then((result) => referenceResultFactory(result, this.provider, collectionName, undefined, undefined, safeOptions));
        }));
        this.fetchAggregate = withArgs((args, collectionName, cursor, limit, options) => apiValidator()
            .arity('fetchAggregate', args, 3, 4)
            .isNonEmptyString(cursor, 'cursor')
            .validateAndReject()
            .then(() => {
            const aggregateRequest = aggregateFetchFactory(this.provider, collectionName, limit, cursor);
            return aggregateRequest.run(options);
        }));
        this.queryReferenced = withArgs((args, collectionName, holdingItem, relationshipAttribute, options) => apiValidator()
            .arity('queryReferenced', args, 3, 4)
            .referenceParameter(holdingItem)
            .validateAndReject()
            .then(() => {
            const itemId = normalizeRefParameter(holdingItem);
            const safeOptions = options || {};
            return this.provider
                .queryReferenced(collectionName, itemId, relationshipAttribute, safeOptions)
                .then((result) => referenceResultFactory(result, this.provider, collectionName, itemId, relationshipAttribute, options));
        }));
        this.insertReference = withArgs((args, collectionName, relationshipAttribute, left, right, options) => {
            const normalizeRefs = (refs) => refs.map((ref) => ({
                relationshipName: ref.relationshipName,
                left: normalizeRefParameter(ref.left),
                right: normalizeRefParameter(ref.right),
            }));
            let opts;
            let refs;
            let validate;
            if (isArray(relationshipAttribute)) {
                refs = relationshipAttribute;
                opts = left;
                validate = () => apiValidator()
                    .arity('insertReference', args, 2, 3)
                    .references(refs)
                    .validateAndReject();
            }
            else {
                refs = arrify(right).map((r) => ({
                    relationshipName: relationshipAttribute,
                    left,
                    right: r,
                }));
                opts = options;
                validate = () => apiValidator()
                    .arity('insertReference', args, 4, 5)
                    .references(refs)
                    .validateAndReject();
            }
            return validate().then(() => this.provider.insertReferences(collectionName, normalizeRefs(refs), opts));
        });
        this.replaceReferences = withArgs((args, collectionName, relationshipAttribute, left, right, options) => {
            right = arrify(right).map(normalizeRefParameter);
            left = normalizeRefParameter(left);
            return apiValidator()
                .arity('replaceReferences', args, 4, 5)
                .referenceParameter(left)
                .referenceParameters(right)
                .validateAndReject()
                .then(() => this.provider.replaceReferences(collectionName, {
                relationshipName: relationshipAttribute,
                left,
            }, right.map((r) => ({
                relationshipName: relationshipAttribute,
                right: r,
                left,
            })), options));
        });
        this.removeReference = withArgs((args, collectionName, relationshipAttribute, left, right, options) => {
            right = arrify(right).map(normalizeRefParameter);
            left = normalizeRefParameter(left);
            return apiValidator()
                .arity('removeReference', args, 4, 5)
                .referenceParameter(left)
                .referenceRemoveParameters(right)
                .validateAndReject()
                .then(() => {
                if (right.length === 1) {
                    return this.provider.removeReference(collectionName, relationshipAttribute, left, right[0], options);
                }
                else {
                    return this.provider.removeReferences(collectionName, right.map((r) => ({
                        relationshipName: relationshipAttribute,
                        right: r,
                        left,
                    })), options);
                }
            });
        });
        this.isReferenced = withArgs((args, collectionName, relationshipAttribute, left, right, options) => apiValidator()
            .arity('isReferenced', args, 4, 5)
            .referenceParameter(left)
            .referenceParameter(right)
            .validateAndReject()
            .then(() => this.provider.isReferenced(collectionName, relationshipAttribute, normalizeRefParameter(left), normalizeRefParameter(right), options)));
        this.bulkInsert = withArgs((args, collectionName, items, options) => apiValidator()
            .arity('bulkInsert', args, 2, 3)
            .validateAndReject()
            .then(() => this.provider.bulkInsert(collectionName, items, options))
            .then((bulkResult) => {
            const errors = bulkResult.errors.map((err) => new BulkError(err.message, err.code, err.item, err.name, err.originalIndex));
            return { ...bulkResult, errors };
        }));
        this.bulkSave = withArgs((args, collectionName, items, options) => apiValidator()
            .arity('bulkSave', args, 2, 3)
            .validateAndReject()
            .then(() => this.provider.bulkSave(collectionName, items, options))
            .then((bulkResult) => {
            const errors = bulkResult.errors.map((err) => new BulkError(err.message, err.code, err.item, err.name, err.originalIndex));
            return { ...bulkResult, errors };
        }));
        this.bulkUpdate = withArgs((args, collectionName, items, options) => apiValidator()
            .arity('bulkUpdate', args, 2, 3)
            .validateAndReject()
            .then(() => this.provider.bulkUpdate(collectionName, items, options))
            .then((bulkResult) => {
            const errors = bulkResult.errors.map((err) => new BulkError(err.message, err.code, err.item, err.name, err.originalIndex));
            return { ...bulkResult, errors };
        }));
        this.getSchema = () => this.provider.getSchema();
        this.group = (...fieldName) => groupFactory(...fieldName);
        this.aggregate = (collectionName) => aggregateFactory(this.provider, collectionName);
        this.provider = provider;
    }
    get wixData() {
        return this;
    }
}
/** enriches given function with arguments object */
function withArgs(f) {
    return function (...others) {
        return f(arguments, ...others);
    };
}
function mutate(wixData, functionName, requireId = false) {
    return (collectionName, item, options) => apiValidator()
        .collectionName(collectionName)
        .item(item, collectionName, requireId)
        .options(options)
        .validateAndReject()
        .then(() => warnAboutBrokenFields(item))
        .then(() => wixData[functionName](collectionName, item, options))
        .then(passOrWrap)
        .then(updateOriginalItem(item));
}
function passOrWrap(item) {
    if (item && item.hasOwnProperty('item')) {
        return item.item;
    }
    else {
        return item;
    }
}
function updateOriginalItem(originalItem) {
    return function onItemResponse(item) {
        if (item) {
            for (const prop in item) {
                if (item.hasOwnProperty(prop)) {
                    if (!originalItem.hasOwnProperty(prop) ||
                        Object.getOwnPropertyDescriptor(originalItem, prop)?.writable ===
                            true) {
                        originalItem[prop] = item[prop];
                    }
                }
            }
            for (const prop in originalItem) {
                if (!item.hasOwnProperty(prop)) {
                    delete originalItem[prop];
                }
            }
            return originalItem;
        }
        else {
            return undefined;
        }
    };
}
function arrify(obj) {
    if (isArray(obj)) {
        return obj;
    }
    return [obj];
}
function normalizeRefParameter(param) {
    return isObject(param) ? param._id : param;
}
function warnAboutBrokenFields(item) {
    const hasFieldWithDollar = hasField(item, (key) => key.startsWith('$'));
    const hasFieldWithDot = hasField(item, (key) => key.includes('.'));
    if (hasFieldWithDollar) {
        console.error("Data inserted contains field name prefixed with symbol '$'. It is not recommended to use such field names as it will not work with some data operations.");
    }
    if (hasFieldWithDot) {
        console.warn("Data inserted contains field name containing symbol '.'. It is not recommended to use such field names as it will not work with some data operations.");
    }
}
//# sourceMappingURL=data-api.js.map