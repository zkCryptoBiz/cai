function isDate(obj) {
    if (Object.prototype.toString.call(obj) !== '[object Date]') {
        return false;
    }
    return !isNaN(obj.getTime());
}
const isDateString = (string) => isNaN(string) && !isNaN(new Date(string).getDate());
export function parseEntityJson(entityJson) {
    let lastDate = null;
    return JSON.parse(entityJson, function (k, v) {
        if (k === '$date' && isDateString(v)) {
            lastDate = new Date(v);
        }
        else if (k === '$date') {
            lastDate = { $date: v };
        }
        else if (lastDate !== null) {
            const tmp = lastDate;
            lastDate = null;
            return tmp;
        }
        else {
            return v;
        }
    });
}
export function parseDates(json) {
    if (typeof json !== 'object' || isDate(json)) {
        return json;
    }
    const obj = copyRoot(json);
    for (const k in obj) {
        if (obj[k] && obj[k].$date && isDateString(obj[k].$date)) {
            obj[k] = new Date(obj[k].$date);
        }
        else if (typeof obj[k] === 'object' && obj[k] !== null) {
            obj[k] = parseDates(obj[k]);
        }
    }
    return obj;
}
export function serializeDates(json) {
    if (typeof json !== 'object' || isDate(json)) {
        return json;
    }
    const obj = copyRoot(json);
    for (const k in obj) {
        if (obj[k] && isDate(obj[k])) {
            obj[k] = stringifyDate(obj[k]);
        }
        else if (typeof obj[k] === 'object' && obj[k] !== null) {
            obj[k] = serializeDates(obj[k]);
        }
    }
    return obj;
}
export function stringifyEntityJson(item) {
    function transform(key, value) {
        return stringifyDateReplacer(this, key, value);
    }
    return JSON.stringify(item, transform);
}
function stringifyDateReplacer(obj, key, value) {
    if (key && isDate(obj[key])) {
        return stringifyDate(obj[key]);
    }
    return value;
}
function stringifyDate(v) {
    return {
        $date: v.toJSON(),
    };
}
function copyRoot(obj) {
    if (Array.isArray(obj)) {
        return Object.assign([], obj);
    }
    else {
        return { ...obj };
    }
}
//# sourceMappingURL=serialization.js.map