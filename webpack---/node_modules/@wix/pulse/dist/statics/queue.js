import { webVitalsReport } from '@wix/bi-logger-viewer-data/v2';
import { normalizeUrl } from './utils/url';
import { getHtmlElementMetadataWrapper, toPulseMetric } from './pulse-metric';
import { logBiWithEssentials } from './utils/log-bi-with-essential';
export default class Queue {
    // Internal business logic
    _map = new Map();
    _biLogger;
    _pulseLogger;
    // Data added to the event
    _navigationId;
    _navType;
    _url;
    _platform;
    _attributions;
    _getHtmlElementMetadata = () => ({ compType: 'pulse-not-initialized' });
    constructor({ url, platform, biLogger, pulseLogger, navigationId, navType, attributions, getHtmlElementMetadata, }) {
        this._url = normalizeUrl(url);
        this._platform = platform;
        this._biLogger = biLogger;
        this._pulseLogger = pulseLogger;
        this._navigationId = navigationId;
        this._navType = navType;
        this._attributions = attributions;
        this.getHtmlElementMetadata = getHtmlElementMetadata;
    }
    set getHtmlElementMetadata(getHtmlElementMetadata) {
        this._getHtmlElementMetadata = getHtmlElementMetadataWrapper(getHtmlElementMetadata);
    }
    flushQueue() {
        if (this._map.size > 0) {
            // We want to avoid throwing uncaught exceptions since we're running in the platform.
            try {
                let webVitals = {};
                const metadataObject = {};
                for (const [metricName, pulseMetric] of this._map.entries()) {
                    const { metadata: metricMetadata, ...rest } = pulseMetric;
                    if (metricMetadata) {
                        metadataObject[metricName] = metricMetadata;
                    }
                    webVitals = {
                        ...webVitals,
                        ...rest,
                    };
                }
                let metadata;
                try {
                    if (Object.keys(metadataObject).length > 0) {
                        metadata = JSON.stringify(metadataObject);
                    }
                }
                catch (e) {
                    metadata = 'Failed to stringify metadata';
                }
                const report = {
                    platform: this._platform,
                    url: this._url,
                    navigationId: this._navigationId,
                    navType: this._navType,
                    deviceMemory: navigator.deviceMemory,
                    effectiveNetworkType: navigator.connection?.effectiveType,
                    ...webVitals,
                    metadata,
                    ...this._attributions,
                };
                const event = webVitalsReport(report);
                logBiWithEssentials(this._biLogger, event, true);
                this._pulseLogger.info('Flushing queue', event);
            }
            catch (e) {
                this._pulseLogger.error('Failed to flush queue', e);
            }
            this._map.clear();
        }
    }
    addToQueue(metric) {
        this._pulseLogger.info(`Adding metric to queue: ${metric.name}`, metric);
        let pulseMetric;
        try {
            pulseMetric = toPulseMetric(metric, this._getHtmlElementMetadata);
        }
        catch (e) {
            pulseMetric = {
                metadata: { error: `Error converting ${metric.name} to PulseMetric` },
            };
        }
        this._map.set(metric.name, pulseMetric);
    }
}
//# sourceMappingURL=queue.js.map