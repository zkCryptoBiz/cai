import { onTTFB, onFCP, onLCP, onCLS, onINP } from 'web-vitals/attribution';
import Queue from './queue';
import { createPulseLogger } from './utils/pulse-logger';
import { pulseError, pulseInitialized, pulseUpdated, } from '@wix/bi-logger-viewer-data/v2';
import { logBiWithEssentials } from './utils/log-bi-with-essential';
export class Pulse {
    _platform;
    _biLogger;
    _debug = false;
    _queues = new Map();
    _url = window.location.href;
    _pulseLogger;
    _attributions;
    _getHtmlElementMetadata = () => ({});
    constructor(platform, config) {
        this._platform = platform;
        // If a biLoggerFactory is provided, use it to create a biLogger instance.
        if (!config.biLoggerFactory && !config.biLogger) {
            throw new Error(`biLogger or biLoggerFactory must be provided`);
        }
        this._biLogger = config.biLoggerFactory
            ? config.biLoggerFactory({ useBatch: true }).logger()
            : config.biLogger;
        this._attributions = config.attributions;
        // We want to report Pulse initialization as soon as we can
        logBiWithEssentials(this._biLogger, pulseInitialized({
            platform: this._platform,
            ...this._attributions,
        }));
        this._debug = config.debug || false;
        if (config.getHtmlElementMetadata) {
            this._getHtmlElementMetadata = config.getHtmlElementMetadata;
        }
        const searchQuery = new URLSearchParams(window.location.search);
        this._pulseLogger = createPulseLogger(this._debug || searchQuery.has('debugPulse'));
        try {
            this._initListeners();
        }
        catch (e) {
            console.error('Failed to initialze Pulse listeners', e);
            this._reportErrorToBi(e, 'Pulse Listeners Initialization');
        }
    }
    update({ getHtmlElementMetadata, }) {
        // We want to report Pulse update as soon as we can
        try {
            logBiWithEssentials(this._biLogger, pulseUpdated({
                platform: this._platform,
                ...this._attributions,
            }));
            this._getHtmlElementMetadata = getHtmlElementMetadata;
            // Update all queues with the new getHtmlElementMetadata function
            for (const queue of this._queues.values()) {
                queue.getHtmlElementMetadata = this._getHtmlElementMetadata;
            }
        }
        catch (e) {
            console.error('Failed update Pulse', e);
            this._reportErrorToBi(e, 'Pulse Update');
        }
    }
    addMetricToQueue(metric) {
        const { navigationType: navType } = metric;
        const navigationId = 1;
        if (!this._queues.has(navigationId.toString())) {
            this._queues.set(navigationId.toString(), new Queue({
                url: this._url,
                platform: this._platform,
                biLogger: this._biLogger,
                pulseLogger: this._pulseLogger,
                attributions: this._attributions,
                getHtmlElementMetadata: this._getHtmlElementMetadata,
                navigationId: navigationId.toString(),
                navType,
            }));
        }
        this._queues.get(navigationId.toString())?.addToQueue(metric);
    }
    _flushQueues() {
        for (const queue of this._queues.values()) {
            queue.flushQueue();
        }
    }
    _initListeners() {
        onTTFB((metric) => {
            this.addMetricToQueue(metric);
            this._reportStepToBi('TTFB', 'TTFB added to queue');
        });
        onFCP((metric) => {
            this.addMetricToQueue(metric);
            this._reportStepToBi('FCP', 'FCP added to queue');
        });
        onLCP((metric) => {
            this.addMetricToQueue(metric);
            this._reportStepToBi('LCP', 'LCP added to queue');
        });
        onCLS((metric) => {
            this.addMetricToQueue(metric);
            this._reportStepToBi('CLS', 'CLS added to queue');
        });
        onINP((metric) => this.addMetricToQueue(metric), {
            reportAllChanges: true,
        });
        let pageMetricsAdded = false;
        const addPageMetricsToQueue = () => {
            if (pageMetricsAdded) {
                return;
            }
            const navigationType = performance.getEntriesByType('navigation')[0]
                ?.type;
            this.addMetricToQueue({ name: 'Page', navigationType });
            this._reportStepToBi('Page', 'Page added to queue');
            pageMetricsAdded = true;
        };
        // Still using this so it will works for CLS and INP
        // Report all available metrics whenever the page is backgrounded or unloaded.
        addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                this._reportStepToBi('Visibility Change', 'Visibility change');
                addPageMetricsToQueue();
                this._flushQueues();
            }
        });
        // NOTE: Safari does not reliably fire the `visibilitychange` event when the
        // page is being unloaded. If Safari support is needed, you should also flush
        // the queue in the `pagehide` event.
        addEventListener('pagehide', () => {
            this._reportStepToBi('Visibility Change', 'Visibility change pagehide');
            addPageMetricsToQueue();
            this._flushQueues();
        });
    }
    _reportErrorToBi(e, step) {
        logBiWithEssentials(this._biLogger, pulseError({
            platform: this._platform,
            ...this._attributions,
            message: e instanceof Error ? e.message : 'No error message',
            step,
        }));
    }
    // TODO: Temporary method for debug purposes
    _reportStepToBi(step, message) {
        logBiWithEssentials(this._biLogger, pulseError({
            platform: this._platform,
            ...(isVisitorAttribution(this._attributions) && {
                sessionId: this._attributions.sessionId,
            }),
            ...(this._attributions.msid && { msid: this._attributions.msid }),
            ...(isVisitorAttribution(this._attributions) && {
                vsi: this._attributions.vsi,
            }),
            message,
            step,
        }));
    }
}
function isVisitorAttribution(attributions) {
    return attributions.vsi !== undefined;
}
//# sourceMappingURL=pulse.js.map