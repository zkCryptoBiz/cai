import { normalizeUrl } from '../../utils/url';
function calculateIsINPeventDuringNavigation(inpStartTime, navigationParams) {
    if (!navigationParams) {
        return undefined;
    }
    if (navigationParams.isDuringNavigation) {
        return true;
    }
    if (!navigationParams.lastNavigationTimings) {
        return undefined;
    }
    const { start: navigationStart, end: navigationEnd } = navigationParams.lastNavigationTimings;
    return navigationStart && navigationEnd
        ? inpStartTime >= navigationStart && inpStartTime <= navigationEnd
        : undefined;
}
const getEventTarget = ({ entries }) => {
    /**
     * There is a bug in Chrome due to which it sometimes would not report target for some events:
     * https://bugs.chromium.org/p/chromium/issues/detail?id=1367329
     * In order to get the target matching the selector, we should use the same logic web-vitals use for finding the target selector:
     * https://github.com/GoogleChrome/web-vitals/blob/c963a5723a78bd7eec51bb9e50283aafc23b3388/src/attribution/onINP.ts#L211-L215
     */
    return entries.find((entry) => entry.target)?.target;
};
const getLoafs = (longAnimationFrameEntries) => {
    // TODO: once we decide on which fields to include in the loaf,
    // we should update this function and filter out the fields that are not needed
    return longAnimationFrameEntries.length > 0
        ? JSON.stringify(longAnimationFrameEntries)
        : undefined;
};
export const toInpMetric = (metric, getHtmlElementMetadata) => {
    const { value, attribution: { interactionTime, interactionTarget, interactionType, loadState, inputDelay, processingDuration, presentationDelay, nextPaintTime, longAnimationFrameEntries, }, } = metric;
    const htmlElementMetadata = getHtmlElementMetadata(getEventTarget(metric) || null);
    const navigationParams = htmlElementMetadata.navigationParams;
    const inpIsDuringNavigation = calculateIsINPeventDuringNavigation(interactionTime, navigationParams);
    return {
        inpValue: Math.trunc(value),
        inpUrl: normalizeUrl(window.location.href),
        inpRating: metric.rating,
        inpInteractionType: interactionType,
        inpTargetSelector: interactionTarget,
        inpStartTime: interactionTime ? Math.trunc(interactionTime) : undefined,
        inpInputDelay: Math.trunc(inputDelay),
        inpProcessingDuration: Math.trunc(processingDuration),
        inpPresentationDelay: Math.trunc(presentationDelay),
        inpLoadState: loadState,
        inpNextPaintTime: Math.trunc(nextPaintTime),
        inpComponentType: htmlElementMetadata.compType,
        inpWidgetId: htmlElementMetadata.widgetId,
        inpApplicationId: htmlElementMetadata.applicationId,
        inpIsDuringNavigation,
        inpLoafs: getLoafs(longAnimationFrameEntries),
    };
};
//# sourceMappingURL=inp.js.map