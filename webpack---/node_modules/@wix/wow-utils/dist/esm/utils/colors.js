export * from '../types';

/**
 * Convert HSB (or HSV) color values to RGB color values.
 * @param h - The hue value (0-360).
 * @param s - The saturation value (0-100).
 * @param v - The brightness value (0-100).
 * @returns An array containing the red, green, and blue values in the RGB color model.
 */
export function hsb2rgb(h, s, v) {
  s = s / 100;
  v = v / 100;

  // input: h in [0,360] and s,v in [0,1]
  const f = function (n, k) {
    if (k === void 0) {
      k = (n + h / 60) % 6;
    }
    return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  };
  return [Math.round(f(5) * 255), Math.round(f(3) * 255), Math.round(f(1) * 255)];
}

/**
 * Convert RGB color values to HSB (or HSV) color values.
 * @param r - The red color value (0-255).
 * @param g - The green color value (0-255).
 * @param b - The blue color value (0-255).
 * @returns An array containing the hue, saturation, and brightness values in the HSB color model.
 */
export function rgb2hsb(r, g, b) {
  r = r / 255;
  g = g / 255;
  b = b / 255;

  // input: r,g,b in [0,1]
  const v = Math.max(r, g, b);
  const c = v - Math.min(r, g, b);
  const h = c && (v === r ? (g - b) / c : v === g ? 2 + (b - r) / c : 4 + (r - g) / c);
  return [60 * (h < 0 ? h + 6 : h), (v && c / v) * 100, v * 100];
}

/**
 * Convert HEX color value to RGB color values.
 * @param hex - The hexadecimal color value.
 * @returns An array containing the red, green, and blue values in the RGB color model.
 */
export function hex2rgb(hex) {
  const bigint = parseInt(hex.slice(1) || '0', 16);
  const r = bigint >> 16 & 255;
  const g = bigint >> 8 & 255;
  const b = bigint & 255;
  return [r, g, b];
}

/**
 * Convert RGB color values to HEX color value.
 * @param r - The red color value (0-255).
 * @param g - The green color value (0-255).
 * @param b - The blue color value (0-255).
 * @returns The hexadecimal color value.
 */
export function rgb2hex(r, g, b) {
  return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
}

/**
 * Convert HSB (or HSV) color values to HSL color values.
 * @param h - The hue value (0-360).
 * @param s - The saturation value (0-100).
 * @param b - The brightness value (0-100).
 * @returns An array containing the hue, saturation, and lightness values in the HSL color model.
 */
export function hsb2hsl(h, s, b) {
  b = b / 100;
  s = s / 100;
  const hue = h;
  const l = b * (1 - s / 2);
  const saturation = l === 0 || l === 1 ? 0 : (b - l) / Math.min(l, 1 - l) * 100;
  const lightness = l * 100;
  return [hue, saturation, lightness];
}

/**
 * Parse rgba (or rgb) array from a string.
 * @param rgba - The string containing the rgba (or rgb) color values.
 * @returns An array containing the red, green, blue, and alpha values in the RGBA color model.
 */
export function str2rgba(rgba) {
  const [, ...rgbaArr] = rgba.match(/(\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})(?:,\s*(\d*(?:\.\d+)?))?/) || ['_', '0', '0', '0', '0'];
  return rgbaArr.filter(num => num).map(num => +num);
}

/**
 * Convert HSB (or HSV) color values to HEX color value.
 * @param h - The hue value (0-360).
 * @param s - The saturation value (0-100).
 * @param b - The brightness value (0-100).
 * @returns The hexadecimal color value.
 */
export function hsb2hex(h, s, b) {
  return rgb2hex(...hsb2rgb(h, s, b));
}

/**
 * Convert HEX color value to HSB (or HSV) color values.
 * @param hex - The hexadecimal color value.
 * @returns An array containing the hue, saturation, and brightness values in the HSB color model.
 */
export function hex2hsb(hex) {
  return rgb2hsb(...hex2rgb(hex));
}

/**
 * Return luminance in range of [0-1] for given RGB values in ranges of [0-255].
 * @param r - The red color value (0-255).
 * @param g - The green color value (0-255).
 * @param b - The blue color value (0-255).
 * @returns The luminance value.
 */
export function getLuminance(r, g, b) {
  return (r * 0.3 + g * 0.6 + b * 0.1) / 255;
}

/**
 * Return true if a string is a HEX color.
 * @param color - The color string.
 * @returns A boolean indicating if the string is a HEX color.
 */
export function isHex(color) {
  return /^#(?:[0-9a-fA-F]{3}){1,2}$/i.test(color);
}

/**
 * Return true if a string is a comma separated RGB color (doesn't support new rgb(r g b / a)).
 * @param color - The color string.
 * @returns A boolean indicating if the string is a comma separated RGB color.
 */
export function isRgb(color) {
  return /^rgb\((\d{1,3}%?),\s*(\d{1,3}%?),\s*(\d{1,3}%?)\)$/.test(color);
}

/**
 * Return true if a string is a comma separated RGBA color (doesn't support new rgb(r g b / a)).
 * @param color - The color string.
 * @returns A boolean indicating if the string is a comma separated RGBA color.
 */
export function isRgba(color) {
  return /^rgba\((\d{1,3}%?),\s*(\d{1,3}%?),\s*(\d{1,3}%?),\s*(\d*(?:\.\d+)?)\)$/.test(color);
}

// TODO: TESTS

/**
 * Convert hex color (with or withour alpha) and a passed alpha value to an rgba string
 * NOTE: Returns black if hex is not valid
 * @param hex color in the format of #FFF #FFFFFF or #FFFFFFFF
 * @param  alpha a value between 0 and 1 representing global alpha value to aplly to all gradients
 * @returns rgba(255,255,255,100)
 */
export function hex2rgba(hex, alpha) {
  if (alpha === void 0) {
    alpha = 1;
  }
  const shortHex = hex.length === 4;
  const matcher = shortHex ? /[0-9a-f]/gi : /[0-9a-f]{2}/gi;
  const hexArray = hex.match(matcher);
  if (!hexArray) {
    return 'rgba(0,0,0,100)';
  }
  const [r, g, b, a = 255] = hexArray.map(x => parseInt(x.repeat(shortHex ? 2 : 1), 16));
  return `rgba(${r},${g},${b},${a / 255 * alpha})`;
}

/**
 *
 * @param wixRgba r,g,b,a
 * @returns touple of hex color and alpha
 */
export function wrgba2hex_a(wixRgba) {
  const [r, g, b, a] = wixRgba.split(/,\s*/);
  return [`#${((1 << 24) + (+r << 16) + (+g << 8) + +b).toString(16).slice(1).toUpperCase()}`, +a];
}
//# sourceMappingURL=colors.js.map