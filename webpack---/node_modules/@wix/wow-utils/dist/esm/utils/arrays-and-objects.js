/**
 * Check if value is iterable
 *
 * @param value - The value to check.
 * @returns A boolean indicating whether the value is iterable.
 */
export const isIterable = value => value !== null && Symbol.iterator in Object(value);

/**
 * Convert value to array:
 * if it's iterable, convert to an array
 * if it's null, return an empty array
 * if it's not iterable, return an array with the value as the only element
 *
 * @param obj - The value to convert to an array.
 * @returns An array representation of the value.
 */
export const toArray = function (obj) {
  if (obj === void 0) {
    obj = [];
  }
  return isIterable(obj) && typeof obj !== 'string' ? Array.from(obj) : obj === null ? [] : [obj];
};

/**
 * Union arrays.
 * Changed to a better implementation from here https://stackoverflow.com/a/27664971
 *
 * @param arr - The arrays to union.
 * @returns A new array containing the union of all input arrays.
 */
export const unionArrays = function () {
  return Array.from(new Set([].concat(...arguments)));
};

/**
 * Omit keys from object, return new object.
 * Like lodash _.omit.
 *
 * @param obj - The original object.
 * @param keys - An array of keys to be omitted from the object.
 * @returns A new object without the specified keys.
 */
export const omit = (obj, keys) => Object.fromEntries(Object.entries(obj).filter(_ref => {
  let [key] = _ref;
  return !keys.includes(key);
}));

/**
 * Deep compare two objects.
 *
 * @param source - The source object.
 * @param target - The target object.
 * @returns A boolean indicating whether the objects are equal.
 */
export function compareNestedObjects(source, target, keysToIgnore) {
  if (keysToIgnore === void 0) {
    keysToIgnore = [];
  }
  // if primitives are equal we are equal
  if (source === target) {
    return true;
  }
  // if one of the values is null or not an object we don't need to compare further and return false
  if (source === null || target === null || typeof source !== 'object' || typeof target !== 'object') {
    return false;
  }
  // if the objects have different number of keys we are not equal (for objects or arrays)
  const sourceKeys = Object.keys(source).filter(key => !keysToIgnore.includes(key));
  const targetKeys = Object.keys(target).filter(key => !keysToIgnore.includes(key));
  if (sourceKeys.length !== targetKeys.length) {
    return false;
  }
  // check that keys in source are in target and recursively compare them
  for (const key of sourceKeys) {
    if (key in target && compareNestedObjects(source[key], target[key], keysToIgnore)) {
      continue;
    } else {
      return false;
    }
  }
  return true;
}

/**
 * Get a new object with sorted keys and nested objects.
 *
 * @param source - The source object or array.
 * @returns A new object with sorted keys and nested objects.
 */
export function getSortedNestedObjects(source) {
  if (Array.isArray(source)) {
    return source.map(item => getSortedNestedObjects(item));
  }
  if (typeof source === 'object' && source !== null) {
    const sortedObject = {};
    Object.keys(source).sort().forEach(key => {
      sortedObject[key] = getSortedNestedObjects(source[key]);
    });
    return sortedObject;
  }
  return source;
}

/**
 * get a non-cryptographic hash of a string
 * @param input a string to hash
 * @returns a hash of the input string
 */
export async function getSimpleHash(input) {
  const textAsBuffer = new TextEncoder().encode(input);
  const hashBuffer = await globalThis.crypto.subtle.digest('SHA-1', textAsBuffer);
  const hashArray = new Uint8Array(hashBuffer);
  const hash = Array.from(hashArray).map(item => item.toString(16)).join('');
  return hash;
}

/**
 * Compare two ColorLayer data items (gradients data) as nested objects
 * @param a
 * @param b
 * @returns Whether the objects are equal
 */
export function compareColorLayer(a, b) {
  return compareNestedObjects(a, b, ['id', 'metaData']);
}

/**
 * Generate a hash of an object, will sort the nested objects before hashing
 * @param obj
 * @returns hash of the object
 */
export function hashObject(obj) {
  return getSimpleHash(JSON.stringify(getSortedNestedObjects(obj)));
}
//# sourceMappingURL=arrays-and-objects.js.map