import { alignTypes, fittingTypes, getData, isWEBP, getFileExtension, fileType, } from '@wix/image-kit';
const CSS_NUMERIC_VALUES = {
    columnCount: 1,
    columns: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    zIndex: 1,
    zoom: 1,
};
const pick = (obj, props) => {
    const propsArr = Array.isArray(props) ? props : [props];
    return propsArr.reduce((subObj, prop) => {
        const val = obj[prop];
        return val !== undefined ? Object.assign(subObj, { [prop]: val }) : subObj;
    }, {});
};
const addDefaultUnitIfNeeded = (prop, value) => typeof value === 'number' &&
    !CSS_NUMERIC_VALUES[prop]
    ? `${value}px`
    : value.toString();
const setStyle = (node, styleProperties) => node &&
    styleProperties &&
    Object.keys(styleProperties).forEach((prop) => {
        const styleProp = prop;
        const propValue = styleProperties[styleProp];
        if (propValue !== undefined) {
            node.style[styleProp] = addDefaultUnitIfNeeded(styleProp, propValue);
        }
        else {
            node.style.removeProperty(styleProp);
        }
    });
const getScreenHeight = (heightOverride) => heightOverride ||
    document.documentElement.clientHeight ||
    window.innerHeight ||
    0;
const getImageComputedProperties = (extendedImageInfo, envConsts, htmlTag) => {
    // todo: CLNT-5323 , wixapp sildergallery proxy is generating image data without uri
    if (!extendedImageInfo.targetWidth ||
        !extendedImageInfo.targetHeight ||
        !extendedImageInfo.imageData.uri) {
        return { uri: '', css: {}, transformed: false };
    }
    const { imageData } = extendedImageInfo;
    const fittingType = extendedImageInfo.displayMode || fittingTypes.SCALE_TO_FILL;
    const imageOptions = Object.assign(pick(imageData, ['upscaleMethod']), pick(extendedImageInfo, ['filters', 'encoding']), extendedImageInfo.quality || imageData.quality, {
        hasAnimation: extendedImageInfo?.hasAnimation || imageData?.hasAnimation,
    });
    const devicePixelRatioFromData = extendedImageInfo.imageData.devicePixelRatio || envConsts.devicePixelRatio;
    const devicePixelRatio = getDevicePixelRatio(devicePixelRatioFromData);
    const src = Object.assign(pick(imageData, ['width', 'height', 'crop', 'name', 'focalPoint']), { id: imageData.uri });
    const target = {
        width: extendedImageInfo.targetWidth,
        height: extendedImageInfo.targetHeight,
        htmlTag: (htmlTag || 'img'),
        pixelAspectRatio: devicePixelRatio,
        alignment: extendedImageInfo.alignType || alignTypes.CENTER,
    };
    const imageComputedProperties = getData(fittingType, src, target, imageOptions);
    imageComputedProperties.uri = getMediaUrlByContext(imageComputedProperties.uri, envConsts.staticMediaUrl, envConsts.mediaRootUrl);
    return imageComputedProperties;
};
const getMediaUrlByContext = (imageUri, staticMediaUrl, mediaRootUrl) => {
    const isExternalUrl = /(^https?)|(^data)|(^blob)|(^\/\/)/.test(imageUri);
    if (isExternalUrl) {
        return imageUri;
    }
    let path = `${staticMediaUrl}/`;
    if (imageUri) {
        if (/^micons\//.test(imageUri)) {
            path = mediaRootUrl;
        }
        else if (/[^.]+$/.exec(imageUri)?.[0] === 'ico') {
            // if the image is an icon then it's taken from a slightly different place
            path = path.replace('media', 'ficons');
        }
    }
    return path + imageUri;
};
const getDevicePixelRatio = (devicePixelRatio) => {
    // we should be able to force devicePixelRatio from url by using the query param -
    const queryParams = window.location.search
        .split('&')
        .map((query) => query.split('='));
    const devicePixelRatioQueryParam = queryParams.find((query) => query[0]?.toLowerCase().includes('devicepixelratio'));
    const devicePixelRatioValueForceFromUrl = devicePixelRatioQueryParam?.[1]
        ? Number(devicePixelRatioQueryParam[1])
        : null;
    return devicePixelRatioValueForceFromUrl || devicePixelRatio || 1;
};
const getImageSrc = (imageNode) => imageNode.getAttribute('src');
const isTransformedWEBP = (imageNode, imageUri) => {
    const src = getImageSrc(imageNode) || '';
    const isTransformed = !!src.match(/.webp\/v1\//);
    return isWEBP(imageUri) && isTransformed;
};
const imageIsAnimated = (uri, hasAnimation) => getFileExtension(uri) === fileType.GIF ||
    (getFileExtension(uri) === fileType.WEBP && hasAnimation);
export { getScreenHeight, setStyle, getImageComputedProperties, getImageSrc, isTransformedWEBP, imageIsAnimated, };
//# sourceMappingURL=utils.js.map