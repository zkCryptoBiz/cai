import { gradientConstants } from './constants';
import { isHex, hex2rgba, wrgba2hex_a } from '@wix/wow-utils';
import { isWixRgba } from '@wix/color-kit';
const {
  GRADIENT_LINEAR,
  GRADIENT_CONIC,
  GRADIENT_CIRCLE
} = gradientConstants.TYPES;
const {
  RADIAL_GRADIENT,
  CONIC_GRADIENT,
  LINEAR_GRADIENT
} = gradientConstants.CSS_FUNC;
const {
  REPEATING,
  DEG,
  AT_CENTER,
  CIRCLE,
  ELLIPSE,
  FROM,
  PERCENTAGE
} = gradientConstants;
const OPENING_BRACKET = '(';
const CLOSING_BRACKET = ')';
/**
 *
 * @param gradients List of Objects representing gradient's data.
 * @param options.alpha a value between 0 and 1 representing global alpha value to aplly to all gradients
 * @param options.resolveColor an optional color parsing function for unsupported formats conversion
 * @return CSS string of gradients
 */
function generate(gradients, options) {
  if (gradients === void 0) {
    gradients = [];
  }
  if (options === void 0) {
    options = {};
  }
  if (!Array.isArray(gradients)) {
    gradients = gradients.type === 'GradientMesh' ? gradients.gradients : [gradients];
  }
  return gradients.map(gradient => generateGradientFromDatum(gradient, options)).join(', ');
}

/**
 * Validate if a gradient is valid, currently doing a loose comparison. Will harden the validation if needed
 * @param gradients List of Objects representing gradient's data.
 * @returns Whether the gradients are valid
 */
function validate(gradients) {
  if (!gradients || typeof gradients !== 'object') {
    return false;
  }
  if (Array.isArray(gradients)) {
    return gradients.every(isValidGradient);
  }
  if ('gradients' in gradients && Array.isArray(gradients.gradients)) {
    return gradients.gradients.every(isValidGradient);
  }
  return isValidGradient(gradients);
}
function isValidGradient(gradient) {
  const types = Object.values(gradientConstants.TYPES);
  return gradient && types.includes(gradient.type) && gradient.colorStops && gradient.colorStops.length > 0;
}

/**
 *
 * @param gradient
 * @param options.alpha a value between 0 and 1 representing global alpha value to aplly to all gradients
 * @param options.resolveColor an optional color parsing function for unsupported formats conversion
 * @return Gradient string
 */
function generateGradientFromDatum(gradient, options) {
  const gradientRepeat = gradient.repeat ? `${REPEATING}-` : '';
  const gradientString = generateGradientByType(gradient);
  const gradientColorStops = generateColorStops(gradient.colorStops, options);
  return `${gradientRepeat}${gradientString}${gradientColorStops}${CLOSING_BRACKET}`;
}

/**
 *
 * @param gradient
 * @return gradient type CSS string
 */
function generateGradientByType(gradient) {
  if (gradient.type === GRADIENT_LINEAR) {
    return generateLinear(gradient);
  }
  if (gradient.type === GRADIENT_CONIC) {
    return generateConic(gradient);
  }
  return generateRadial(gradient);
}

/**
 *
 * @param gradient
 * @return linear-gradient string
 */
function generateLinear(_ref) {
  let {
    angle = 0
  } = _ref;
  const gradientAngle = generateGradientAngle(angle, ', ');
  return `${LINEAR_GRADIENT}${OPENING_BRACKET}${gradientAngle}`;
}

/**
 *
 * @param gradient
 * @return radial-gradient string
 */
function generateRadial(_ref2) {
  let {
    size,
    position,
    type
  } = _ref2;
  const gradientSize = generateGradientSize(size);
  const gradientPosition = generateGradientPosition(position, type);
  const radialShape = type === GRADIENT_CIRCLE ? CIRCLE : ELLIPSE;
  return `${RADIAL_GRADIENT}${OPENING_BRACKET}${radialShape} ${gradientSize}${gradientPosition}`;
}

/**
 *
 * @param gradient
 * @return conic-gradient string
 */
function generateConic(_ref3) {
  let {
    angle = 0,
    position,
    type
  } = _ref3;
  const gradientPosition = generateGradientPosition(position, type);
  const gradientAngle = generateGradientAngle(angle);
  const angleDelimiter = position ? ' ' : ', ';
  return `${CONIC_GRADIENT}${OPENING_BRACKET}${FROM} ${gradientAngle}${angleDelimiter}${gradientPosition}`;
}

/**
 *
 * @param data
 * @return background values string
 */
function generateUnitSize(_ref4) {
  let {
    type,
    value
  } = _ref4;
  return `${value}${type === PERCENTAGE ? '%' : type}`;
}

/**
 *
 * @param angle
 * @param suffix defaults to `''`.
 * @return gradient angle string
 */
function generateGradientAngle(angle, suffix) {
  if (suffix === void 0) {
    suffix = '';
  }
  return `${angle}${DEG}${suffix}`;
}
/**
 *
 * @param size
 * @return gradient size string
 */
function generateGradientSize(size) {
  if (!size) {
    return '';
  }
  if ('keyword' in size) {
    return `${size.keyword} `;
  }
  if ('width' in size && 'height' in size) {
    const sizeWidth = generateUnitSize(size.width);
    const sizeHeight = generateUnitSize(size.height);
    return `${sizeWidth} ${sizeHeight} `;
  }
  if ('value' in size && 'type' in size) {
    return `${size.value}${size.type === PERCENTAGE ? '%' : size.type} `;
  }
  return '';
}

/**
 *
 * @param position
 * @param type
 * @return gradient position string
 */
function generateGradientPosition(position, type) {
  // We expect position to always be defined in out types,
  // but we still support optional position for future implementations
  if (!position) {
    if (type === GRADIENT_CONIC) {
      return '';
    }
    return `${AT_CENTER}, `;
  }
  const xPosition = generateUnitSize(position.x);
  const yPosition = generateUnitSize(position.y);
  return `at ${xPosition} ${yPosition}, `;
}

/**
 *
 * @param colorStops
 * @param options.alpha a value between 0 and 1 representing global alpha value to aplly to all gradients
 * @param options.resolveColor an optional color parsing function for unsupported formats conversion
 * @return gradient colorStops string
 */
function generateColorStops(colorStops, options) {
  if (colorStops === void 0) {
    colorStops = [];
  }
  return colorStops.map(colorStop => generateColorStop(colorStop, options)).join(', ');
}

/**
 *
 * @param color hex color or an 'r,g,b,a' string, 'a' is ignored if opacity !== undefined
 * @param opacity 0...1
 * @param size
 * @param alpha a value between 0 and 1 representing global alpha value to aplly to all gradients
 * @param resolveColor an optional color parsing function for unsupported formats conversion
 * @return gradient colorStop string
 */
function generateColorStop(_ref5, _ref6) {
  let {
    color,
    opacity,
    size
  } = _ref5;
  let {
    alpha = 1,
    resolveColor
  } = _ref6;
  let colorStopColor = '';
  let colorStopSize = '';
  if (color) {
    if (resolveColor) {
      color = resolveColor(color);
    }
    if (isHex(color)) {
      opacity ?? (opacity = 1);
      colorStopColor = opacity * alpha < 1 ? hex2rgba(color, opacity * alpha) : color;
    } else if (isWixRgba(color)) {
      const [colorHex, colorAlpha] = wrgba2hex_a(color);
      opacity ?? (opacity = colorAlpha);
      colorStopColor = hex2rgba(colorHex, opacity * alpha);
    } else {
      colorStopColor = color;
    }
  }
  if (size) {
    const {
      type,
      value
    } = size;
    colorStopSize = `${value}${type === PERCENTAGE ? '%' : type}`;
  }
  if (color && size) {
    return `${colorStopColor} ${colorStopSize}`;
  } else if (color) {
    return colorStopColor;
  }
  return colorStopSize;
}
export { generate, validate };
export * from './types';
//# sourceMappingURL=index.js.map