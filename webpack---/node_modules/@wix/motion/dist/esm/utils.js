import easings from './easings';
const CLIP_POLYGON_TEMPLATES = {
  initial: _ref => {
    let {
      top,
      bottom,
      left,
      right
    } = _ref;
    return `${left}% ${top}%, ${right}% ${top}%, ${right}% ${bottom}%, ${left}% ${bottom}%`;
  },
  top: _ref2 => {
    let {
      top,
      left,
      right,
      minimum
    } = _ref2;
    return `${left}% ${top}%, ${right}% ${top}%, ${right}% ${top + minimum}%, ${left}% ${top + minimum}%`;
  },
  right: _ref3 => {
    let {
      top,
      bottom,
      right,
      minimum
    } = _ref3;
    return `${right - minimum}% ${top}%, ${right}% ${top}%, ${right}% ${bottom}%, ${right - minimum}% ${bottom}%`;
  },
  center: _ref4 => {
    let {
      centerX,
      centerY,
      minimum
    } = _ref4;
    return `${centerX - minimum / 2}% ${centerY - minimum / 2}%, ${centerX + minimum / 2}% ${centerY - minimum / 2}%, ${centerX + minimum / 2}% ${centerY + minimum / 2}%, ${centerX - minimum / 2}% ${centerY + minimum / 2}%`;
  },
  bottom: _ref5 => {
    let {
      bottom,
      left,
      right,
      minimum
    } = _ref5;
    return `${left}% ${bottom - minimum}%, ${right}% ${bottom - minimum}%, ${right}% ${bottom}%, ${left}% ${bottom}%`;
  },
  left: _ref6 => {
    let {
      top,
      bottom,
      left,
      minimum
    } = _ref6;
    return `${left}% ${top}%, ${left + minimum}% ${top}%, ${left + minimum}% ${bottom}%, ${left}% ${bottom}%`;
  },
  vertical: _ref7 => {
    let {
      top,
      bottom,
      left,
      right,
      minimum
    } = _ref7;
    return `${left}% ${top + minimum / 2}%, ${right}% ${top + minimum / 2}%, ${right}% ${bottom - minimum / 2}%, ${left}% ${bottom - minimum / 2}%`;
  },
  horizontal: _ref8 => {
    let {
      top,
      bottom,
      left,
      right,
      minimum
    } = _ref8;
    return `${left + minimum / 2}% ${top}%, ${right - minimum / 2}% ${top}%, ${right - minimum / 2}% ${bottom}%, ${left + minimum / 2}% ${bottom}%`;
  }
};
export function getClipPolygonParams(_ref9) {
  let {
    direction,
    scaleX = 1,
    scaleY = 1,
    minimum = 0
  } = _ref9;
  const top = (1 - scaleY) / 2 * 100;
  const left = (1 - scaleX) / 2 * 100;
  const right = 100 + left - (1 - scaleX) * 100;
  const bottom = 100 + top - (1 - scaleY) * 100;
  const centerX = (right + left) / 2;
  const centerY = (bottom + top) / 2;
  return `polygon(${CLIP_POLYGON_TEMPLATES[direction]({
    top,
    bottom,
    left,
    right,
    centerX,
    centerY,
    minimum
  })})`;
}

/**
 * Adjust direction by angle from predefined list
 */
export function getAdjustedDirection(availableDirections, direction, angleInDeg) {
  const index = availableDirections.indexOf(direction);
  const length = availableDirections.length;
  const shiftBy = Math.round((angleInDeg || 0) / 360 * length);
  const newIndex = (index + (length - 1) * shiftBy) % length; // eslint-disable-line no-mixed-operators
  return availableDirections[newIndex];
}
export function transformPolarToXY(angle, distance) {
  const radians = angle * Math.PI / 180;
  const x = Math.cos(radians) * distance;
  const y = Math.sin(radians) * distance;
  return [x, y];
}
export function getCssUnits(type) {
  return type === 'percentage' ? '%' : type || 'px';
}
export function getEasing(easing) {
  return easing ? easings[easing] || easing : easings.linear;
}
export function getEasingFamily(easing) {
  const ease = easing.replace(/In|Out/g, '');
  if (ease === 'linear') {
    return {
      in: `linear`,
      inOut: `linear`,
      out: `linear`
    };
  }
  return {
    in: `${ease}In`,
    inOut: `${ease}InOut`,
    out: `${ease}Out`
  };
}
const MOUSE_TRANSITION_EASING_MAP = {
  linear: 'linear',
  easeOut: 'ease-out',
  hardBackOut: 'cubic-bezier(0.58, 2.5, 0, 0.95)',
  elastic: 'linear( 0, 0.2178 2.1%, 1.1144 8.49%, 1.2959 10.7%, 1.3463 11.81%, 1.3705 12.94%, 1.3726, 1.3643 14.48%, 1.3151 16.2%, 1.0317 21.81%, 0.941 24.01%, 0.8912 25.91%, 0.8694 27.84%, 0.8698 29.21%, 0.8824 30.71%, 1.0122 38.33%, 1.0357, 1.046 42.71%, 1.0416 45.7%, 0.9961 53.26%, 0.9839 57.54%, 0.9853 60.71%, 1.0012 68.14%, 1.0056 72.24%, 0.9981 86.66%, 1 )',
  bounce: 'linear( 0, 0.0039, 0.0157, 0.0352, 0.0625 9.09%, 0.1407, 0.25, 0.3908, 0.5625, 0.7654, 1, 0.8907, 0.8125 45.45%, 0.7852, 0.7657, 0.7539, 0.75, 0.7539, 0.7657, 0.7852, 0.8125 63.64%, 0.8905, 1 72.73%, 0.9727, 0.9532, 0.9414, 0.9375, 0.9414, 0.9531, 0.9726, 1, 0.9883, 0.9844, 0.9883, 1 )'
};
export function getMouseTransitionEasing(value) {
  return value && MOUSE_TRANSITION_EASING_MAP[value] || 'linear';
}
export function deg2rad(angleInDeg) {
  return angleInDeg * Math.PI / 180;
}
export function getTransformParams(originDirection, angleInRad, scale) {
  if (scale === void 0) {
    scale = 1;
  }
  const x = `calc(var(--motion-height, 100%) * ${scale * originDirection.dy * Math.sin(-angleInRad)} + var(--motion-width, 100%) * ${scale * originDirection.dx * Math.cos(angleInRad)})`;
  const y = `calc(var(--motion-height, 100%) * ${scale * originDirection.dy * Math.cos(-angleInRad)} + var(--motion-width, 100%) * ${scale * originDirection.dx * Math.sin(angleInRad)})`;
  return {
    x,
    y
  };
}
export function getOutOfScreenDistance(angle) {
  const angleInRad = angle * Math.PI / 180;
  const angleCos = Math.cos(angleInRad);
  const angleSin = Math.sin(angleInRad);

  // Calculate x and y direction based on angle
  const xDirection = Math.sign(angleCos);
  const yDirection = Math.sign(angleSin);
  const left = `var(--motion-left, 0px)`;
  const top = `var(--motion-top, 0px)`;

  // Calculate x and y distances between component and stage
  const xDistance = xDirection ? xDirection === -1 ? `(-1 * ${left} - 100%)` : `(100vw - ${left})` : 0;
  const yDistance = yDirection ? yDirection === -1 ? `(-1 * ${top} - 100%)` : `(100vh - ${top})` : 0;

  // Calculate hypotenuse
  let hypotenuse;
  const hypotX = `calc(${xDistance} / ${angleCos})`;
  const hypotY = `calc(${yDistance} / ${angleSin})`;
  if (!angleCos) {
    hypotenuse = hypotY;
  } else if (!angleSin) {
    hypotenuse = hypotX;
  } else {
    hypotenuse = `min(${hypotY}, ${hypotX})`;
  }
  return {
    // distance: Math.abs(hypotenuse),
    x: `calc(${hypotenuse} * ${angleCos})`,
    y: `calc(${hypotenuse} * ${angleSin})`
  };
}

// export function translatePoint(
//   width: string,
//   height: string,
//   angleInDeg: number,
// ) {
//   const angleInRad = (angleInDeg * Math.PI) / 180;
//   return {
//     x: `calc(${width} * ${Math.cos(
//       angleInRad,
//     )} - ${height} * ${Math.sin(angleInRad)})`,
//
//     y: `calc(${width} * ${Math.sin(
//       angleInRad,
//     )} + ${height} * ${Math.cos(angleInRad)})`,
//   };
// }

export function keyframesToDuration(keyframes_translation, duration) {
  return keyframes_translation.map((_ref10, idx) => {
    let {
      keyframe
    } = _ref10;
    const stepDuration = keyframe - (idx > 0 ? keyframes_translation[idx - 1].keyframe : 0);
    return duration * (stepDuration / 100);
  });
}
export function setCompHeightCSSVar(dom) {
  let componentHeight = 0;
  dom.measure(target => {
    if (!target) {
      return;
    }
    componentHeight = target.offsetHeight;
  });
  dom.mutate(target => {
    target == null || target.style.setProperty('--motion-comp-height', `${componentHeight}px`);
  });
}
export function getElementOffset(element, parent) {
  let left = element.offsetLeft;
  let top = element.offsetTop;
  let offsetParent = element.offsetParent;
  while (offsetParent) {
    if (parent && offsetParent === parent) {
      break;
    }
    left += offsetParent.offsetLeft;
    top += offsetParent.offsetTop;
    offsetParent = offsetParent.offsetParent;
  }
  return {
    left,
    top
  };
}
const toClipPathString = pointsArr => {
  return pointsArr.map(_ref11 => {
    let {
      x,
      y
    } = _ref11;
    return `${x | 0}% ${y | 0}%`;
  }).join(', ');
};
const generateClipPathArr = (iterStart, iterEnd, shutterCount, staggered, direction) => {
  const inc = direction === 'right' || direction === 'bottom' ? 1 : -1;
  const isVerticalPath = direction === 'top' || direction === 'bottom';
  const isIncrementing = inc > 0;
  const clipPathStart = [];
  const clipPathEnd = [];
  for (let i = iterStart; i !== iterEnd; i += inc) {
    const shutterEndPosInPercentage = 100 * ((i + inc) / shutterCount);
    const clipStart = 100 * (i / shutterCount);
    let clipEnd;
    if (staggered) {
      const staggerFactor = isIncrementing ? 1 + i / shutterCount : 1 + (shutterCount - i) / shutterCount;
      // staggerFactor changes the speed in which the current shutter completes its animation.
      // case = 1: shutter closes at normal rate (as if there is no stagger at all)
      // case > 1: shutter closes faster (the bigger it is, the faster it closes)

      clipEnd = isIncrementing ? shutterEndPosInPercentage * staggerFactor : 100 - (100 - shutterEndPosInPercentage) * staggerFactor;
    } else {
      clipEnd = shutterEndPosInPercentage;
    }
    if (isVerticalPath) {
      clipPathStart.push({
        x: 0,
        y: clipStart
      }, {
        x: 100,
        y: clipStart
      }, {
        x: 100,
        y: clipStart
      }, {
        x: 0,
        y: clipStart
      });
      clipPathEnd.push({
        x: 0,
        y: clipStart
      }, {
        x: 100,
        y: clipStart
      }, {
        x: 100,
        y: clipEnd
      }, {
        x: 0,
        y: clipEnd
      });
    } else {
      clipPathStart.push({
        x: clipStart,
        y: 0
      }, {
        x: clipStart,
        y: 100
      }, {
        x: clipStart,
        y: 100
      }, {
        x: clipStart,
        y: 0
      });
      clipPathEnd.push({
        x: clipStart,
        y: 0
      }, {
        x: clipStart,
        y: 100
      }, {
        x: clipEnd,
        y: 100
      }, {
        x: clipEnd,
        y: 0
      });
    }
  }
  return {
    clipPathStart,
    clipPathEnd
  };
};
const directionHandlers = {
  bottom: (shutterCount, staggered) => generateClipPathArr(0, shutterCount, shutterCount, staggered, 'bottom'),
  top: (shutterCount, staggered) => generateClipPathArr(shutterCount, 0, shutterCount, staggered, 'top'),
  right: (shutterCount, staggered) => generateClipPathArr(0, shutterCount, shutterCount, staggered, 'right'),
  left: (shutterCount, staggered) => generateClipPathArr(shutterCount, 0, shutterCount, staggered, 'left')
};
export function createShuttersPolygon(direction, shutterCount, staggered, reverse) {
  const {
    clipPathStart,
    clipPathEnd
  } = directionHandlers[direction](shutterCount, staggered);
  if (reverse) {
    clipPathStart.reverse();
    clipPathEnd.reverse();
  }
  return {
    clipStart: `polygon(${toClipPathString(clipPathStart)}`,
    clipEnd: `polygon(${toClipPathString(clipPathEnd)})`
  };
}
//# sourceMappingURL=utils.js.map