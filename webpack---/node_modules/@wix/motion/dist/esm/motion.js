import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { scrollAnimations } from './library/scroll';
import { entranceAnimations } from './library/entrance';
import { ongoingAnimations } from './library/ongoing';
import { mouseAnimations } from './library/mouse';
import { backgroundScrollAnimations } from './library/backgroundScroll';
import { getCssUnits, getEasing } from './utils';
import fastdom from 'fastdom';
function getDirection(effect) {
  const alternate = effect.alternate ? 'alternate' : '';
  return effect.reversed ? `${alternate ? `${alternate}-` : ''}reverse` : alternate || 'normal';
}

/**
 * Returns the string representation of the given UnitLengthPercentage object.
 */
function getLength(length) {
  return `${length.value}${getCssUnits(length.type)}`;
}

/**
 * Returns the animation-range value for the given RangeOffset object.
 * @param {RangeOffset} range
 * @param {string|undefined} add
 * @param {boolean} [isEnd]
 */
function getRange(range, add, isEnd) {
  // according to the CSS spec if the end range is a <length> then it is calculated from the start of the named range
  // our model assumes that <length> in end range is calculated from the end of the named range
  return `${range.name} ${isEnd && range.offset.type !== 'percentage' ? `calc(100% + ${getLength(range.offset)}${add ? ` + ${add}` : ''})` : add ? `calc(${getLength(range.offset)} + ${add})` : getLength(range.offset)}`;
}

/**
 * Returns the start and end animation-range values for the given ScrubAnimation object.
 * @param {AnimationDataForScrub} effect
 * @return {{ start: string; end: string }}
 */
function getRanges(effect) {
  return {
    start: getRange(effect.startOffset, effect.startOffsetAdd),
    end: getRange(effect.endOffset, effect.endOffsetAdd, true)
  };
}

/**
 * Returns the element with the given id or null if not found.
 */
function getElement(id) {
  return id ? document.getElementById(id) : null;
}
function measure(target) {
  return fn => fastdom.measure(() => fn(target));
}
function mutate(target) {
  return fn => fastdom.mutate(() => fn(target));
}
function getAnimationTarget(target, part) {
  return target ? `#${target}${part ? `[data-motion-part="${part}"]` : ''}` : '';
}
function getAnimationAsCSS(options, animationName) {
  const {
    duration,
    delay,
    iterations = 1,
    fill,
    easing = 'linear',
    direction,
    composite
  } = options;
  return `${animationName} ${duration === 'auto' ? 'auto' : `${duration}ms`}${delay ? ` ${delay}ms` : ''}${easing}${fill && fill !== 'none' ? ` ${fill}` : ''} ${iterations || 'infinite'}${direction === 'normal' ? '' : ` ${direction}`}${composite ? ` ${composite}` : ''}`;
}

/**
 * Returns a list of AnimationData objects for the given animation options.
 * Animation presets from the library transform the options into a list of AnimationData objects.
 * @param {AnimationOptions} animation
 * @param {HTMLElement|null} target
 * @param {{}} [options]
 * @return {AnimationData[]}
 */
function getNamedEffect(animation, target, options) {
  if (animation.namedEffect) {
    const name = animation.namedEffect.type;
    let preset;

    // check each preset library for the named effect
    if (name in scrollAnimations) {
      preset = scrollAnimations[name];
    } else if (name in entranceAnimations) {
      preset = entranceAnimations[name];
    } else if (name in ongoingAnimations) {
      preset = ongoingAnimations[name];
    } else if (name in mouseAnimations) {
      preset = mouseAnimations[name];
    } else if (name in backgroundScrollAnimations) {
      preset = backgroundScrollAnimations[name];
    }
    if (preset) {
      // if found a matching preset then make the transformation
      let domApi;
      if (target instanceof HTMLElement) {
        domApi = {
          measure: measure(target),
          mutate: mutate(target)
        };
      }

      // validate duration is a number over 0
      if (animation.type === 'TimeAnimationOptions') {
        animation.duration = animation.duration || 1;
      }
      return preset(animation, domApi, options);
    }
  }
  return [];
}

/**
 * @class AnimationGroup
 *
 * A wrapper object for simulating a GroupEffect and managing multiple animations.
 * See: https://www.w3.org/TR/web-animations-2/#grouping-and-synchronization
 */
class AnimationGroup {
  constructor(animations, options) {
    _defineProperty(this, "animations", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "ready", void 0);
    this.animations = animations;
    this.options = options;
    this.ready = (options == null ? void 0 : options.measured) || Promise.resolve();
  }
  play(callback) {
    this.ready.then(() => {
      for (const animation of this.animations) {
        animation.play();
      }
    }).then(() => Promise.all(this.animations.map(animation => animation.ready))).then(callback);
  }
  pause() {
    for (const animation of this.animations) {
      animation.pause();
    }
  }
  reverse(callback) {
    this.ready.then(() => {
      for (const animation of this.animations) {
        animation.reverse();
      }
    }).then(() => Promise.all(this.animations.map(animation => animation.ready))).then(callback);
  }
  progress(p) {
    for (const animation of this.animations) {
      const {
        activeDuration,
        delay
      } = animation.effect.getComputedTiming();
      animation.currentTime = ((delay || 0) + (activeDuration || 0)) * p;
    }
  }
  cancel() {
    for (const animation of this.animations) {
      animation.cancel();
    }
  }
  onFinish(callback) {
    Promise.all(this.animations.map(animation => animation.finished)).then(callback).catch(_error => {
      console.warn('animation was interrupted - aborting onFinish callback - ', _error);
    });
  }
}

// function getInitialFrame(animation: AnimationOptions) {}

function getCSSAnimation(target, animationOptions, trigger) {
  /*
   * @keyframes <name> {
   *   ...
   * }
   *
   * if Scrub and view-progress then:
   *   @supports (animation-timeline: view()) {
   *     #source {
   *       view-timeline: --<trigger>;
   *     }
   *     #target {
   *       animation: <name> auto <easing> both;
   *       animation-timeline: --<trigger>;
   *       animation-range: cover <start> cover <end>;
   *     }
   *   }
   *   @supports not (animation-timeline: view()) {
   *     #target {
   *       animation: <name> 100ms <easing> both paused;
   *     }
   *   }
   *
   * else:
   *   #target {
   *     animation: <name> <duration> <delay> <easing> <fill> <iterations> <play-state>;
   *   }
   */

  const data = getEffectsData(animationOptions, target);
  const isViewProgress = (trigger == null ? void 0 : trigger.trigger) === 'view-progress';
  return data.map((item, index) => {
    const {
      start,
      end
    } = isViewProgress ? getRanges(item.effect) : {};
    return {
      target: getAnimationTarget(target, item.part),
      keyframes: item.effect.keyframes,
      animation: getAnimationAsCSS(item.options, `${item.id}-${index + 1}`),
      id: item.id && `${item.id}-${index + 1}`,
      animationTimeline: isViewProgress ? `--${trigger == null ? void 0 : trigger.id}` : '',
      animationRange: start || end ? `${start} ${end}` : ''
    };
  });
}

/**
 * Process a list of AnimationOptions and returns a list of objects with AnimationData and KeyframeEffectOptions.
 * @param {AnimationOptions} animation
 * @param {HTMLElement|null} target
 * @param {{}} [options]
 * @return {{ effect: AnimationData; options: KeyframeEffectOptions }[]}
 */
function getEffectsData(animation, target, options) {
  // get the processed list of AnimationData objects for the given animation options
  const animations = getNamedEffect(animation, target, options);

  // process each AnimationData object into a KeyframeEffect object
  return animations.map((effect, index) => {
    // prepare the KeyframeEffectOptions object
    const options = {
      fill: effect.fill,
      easing: getEasing(effect.easing),
      iterations: effect.iterations === 0 ? Infinity : effect.iterations || 1,
      composite: effect.composite,
      direction: getDirection(effect)
    };

    // if this is a TimeAnimation then set the duration and delay as time values
    if (effect.type.startsWith('Time')) {
      options.duration = effect.duration;
      options.delay = effect.delay || 0;
    } else {
      // if ViewTimeline is supported
      if (window.ViewTimeline) {
        // set duration to 'auto'
        options.duration = 'auto';
      } else {
        // if ViewTimeline not supported then put a 100ms value in duration get a progress we can easily relate to
        // we split the duration to 99.99ms and delay of 0.01ms to get the fill-mode effect working
        options.duration = 99.99;
        options.delay = 0.01;
      }
    }
    return {
      effect,
      options,
      id: animation.effectId && `${animation.effectId}-${index + 1}`,
      part: effect.part
    };
  });
}

/**
 * Returns an AnimationGroup object for the given target and animation options.
 * @param {string|null} target
 * @param {AnimationOptions} animationOptions
 * @param {{trigger: string, componentId: string}} [trigger]
 * @param {{}} [options]
 * @return {AnimationGroup}
 */
function getWebAnimation(target, animationOptions, trigger, options) {
  const element = getElement(target);
  if ((trigger == null ? void 0 : trigger.trigger) === 'pointer-move') {
    const mouseAnimationFactory = getNamedEffect(animationOptions, element);
    return mouseAnimationFactory(element);
  }
  const data = getEffectsData(animationOptions, element, options);
  let timeline;
  const isViewProgress = (trigger == null ? void 0 : trigger.trigger) === 'view-progress';

  // if this is a ScrubAnimation with view-progress trigger and the browser supports the ViewTimeline API
  if (isViewProgress && window.ViewTimeline) {
    // generate the timeline object
    // @ts-expect-error
    timeline = new ViewTimeline({
      subject: trigger.element || getElement(trigger.componentId)
    });
  }

  // generate an Animation object for each data object
  const animations = data.map(_ref => {
    let {
      effect,
      options,
      id,
      part
    } = _ref;
    const effectTarget = part ? element == null ? void 0 : element.querySelector(`[data-motion-part="${part}"]`) : element;
    const keyframeEffect = new KeyframeEffect(effectTarget || null, [], options);

    // set the keyframes for the KeyframeEffect after measurements and mutations
    fastdom.mutate(() => {
      if ('timing' in effect) {
        keyframeEffect.updateTiming(effect.timing);
      }
      keyframeEffect.setKeyframes(effect.keyframes);
    });
    const animation = isViewProgress && timeline ? new Animation(keyframeEffect, timeline) : new Animation(keyframeEffect);
    // if this is a ScrubAnimation with view-progress trigger and the browser supports the ViewTimeline API
    if (isViewProgress) {
      if (timeline) {
        // set the ranges for the animation after measurements and mutations
        fastdom.mutate(() => {
          const {
            start,
            end
          } = getRanges(effect);
          // @ts-expect-error
          animation.rangeStart = start;
          // @ts-expect-error
          animation.rangeEnd = end;
          animation.play();
        });
      } else {
        const {
          startOffset,
          endOffset
        } = animationOptions;
        // set the ranges for the animation after measurements and mutations
        fastdom.mutate(() => {
          var _offset, _offset2;
          const startOffsetToWrite = effect.startOffset || startOffset;
          const endOffsetToWrite = effect.endOffset || endOffset;
          Object.assign(animation, {
            start: {
              name: startOffsetToWrite.name,
              offset: (_offset = startOffsetToWrite.offset) == null ? void 0 : _offset.value,
              add: effect.startOffsetAdd
            },
            end: {
              name: endOffsetToWrite.name,
              offset: (_offset2 = endOffsetToWrite.offset) == null ? void 0 : _offset2.value,
              add: effect.endOffsetAdd
            }
          });
        });
      }
    }
    if (id) {
      animation.id = id;
    }
    return animation;
  });

  // create an AnimationGroup with the generate animations
  return new AnimationGroup(animations, {
    ...animationOptions,
    trigger: {
      ...(trigger || {})
    },
    // make sure the group is ready after all animation targets are measured and mutated
    measured: new Promise(resolve => fastdom.mutate(resolve))
  });
}

/**
 * Returns all animations that are currently running on the given element.
 * @param {HTMLElement|string} target
 * @param {string} effectId
 * @return {AnimationGroup|null}
 */
function getElementAnimation(target, effectId) {
  const element = typeof target === 'string' ? getElement(target) : target;
  // somehow get the right animations
  const animations = element == null ? void 0 : element.getAnimations().filter(anim => {
    // @ts-expect-error
    const id = anim.id || anim.animationName;
    // if no id/name just return all animations
    return id ? id.startsWith(effectId) : true;
  });
  return animations != null && animations.length ? new AnimationGroup(animations) : null;
}
function getScrubScene(target, animationOptions, trigger, sceneOptions) {
  if (sceneOptions === void 0) {
    sceneOptions = {};
  }
  const {
    disabled,
    ...rest
  } = sceneOptions;
  const animation = getWebAnimation(target, animationOptions, trigger, rest);
  let typeSpecificOptions = {};
  if (trigger.trigger === 'view-progress' && !window.ViewTimeline) {
    // TODO(ameerf): consider doing this only for bgscrub to not affect the other scroll effects
    const viewSource = trigger.element || getElement(trigger.componentId);
    const {
      ready
    } = animation;
    return animation.animations.map(partialAnimation => {
      return {
        /* we use getters for start and end in order to access the animation's start and end
           only when initializing the scrub scene rather than immediately */
        get start() {
          return partialAnimation.start;
        },
        get end() {
          return partialAnimation.end;
        },
        viewSource,
        ready,
        effect(__, p) {
          const {
            activeDuration,
            delay
          } = partialAnimation.effect.getComputedTiming();
          partialAnimation.currentTime = ((delay || 0) + (activeDuration || 0)) * p;
        },
        disabled,
        destroy() {
          partialAnimation.cancel();
        }
      };
    });
  } else if (trigger.trigger === 'pointer-move') {
    const {
      centeredToTarget
    } = animationOptions;
    typeSpecificOptions = {
      target: animation.target,
      centeredToTarget
    };
  }
  return {
    ...typeSpecificOptions,
    effect(__, p) {
      // @ts-expect-error the type of `p` is dependent on the value of `trigger.trigger`
      animation.progress(p);
    },
    disabled,
    destroy() {
      animation.cancel();
    }
  };
}
export {
// getInitialFrame,
getCSSAnimation, getWebAnimation, getElementAnimation, getScrubScene };
//# sourceMappingURL=motion.js.map