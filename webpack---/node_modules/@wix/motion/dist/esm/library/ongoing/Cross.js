import { getElementOffset } from '../../utils';
const FOUR_DIRECTIONS_TRANSLATIONS = {
  // 100cqw - left
  RIGHT: 'calc(var(--motion-parent-width, 100vw) - var(--motion-left, 0px))',
  // left * -1 - width
  LEFT: 'calc(var(--motion-left, 0px) * -1 - var(--motion-width, 100%))',
  // top * -1 - height
  TOP: 'calc(var(--motion-top, 0px) * -1 - var(--motion-height, 100%))',
  // 100cqh - top
  BOTTOM: 'calc(var(--motion-parent-height, 100vh) - var(--motion-top, 0px))'
};
const {
  RIGHT,
  LEFT,
  TOP,
  BOTTOM
} = FOUR_DIRECTIONS_TRANSLATIONS;
const FOUR_CORNERS_TRANSLATIONS = {
  'top-left': {
    // min(100cqw - left, 100cqh - top)
    from: `min(${RIGHT}, ${BOTTOM})`,
    // min(abs(left * -1 - width), abs(top * -1 - height))
    to: `min(calc(${LEFT} * -1), calc(${TOP} * -1))`
  },
  'top-right': {
    // min(abs(left * -1 - width), 100cqh - top)
    from: `min(calc(${LEFT} * -1), ${BOTTOM})`,
    // min(100cqw - left, abs(top * -1 - height))
    to: `min(${RIGHT}, calc(${TOP} * -1))`
  },
  'bottom-left': {
    // min(100cqw - left, abs(top * -1 - height))
    from: `min(${RIGHT}, calc(${TOP} * -1))`,
    // min(abs(left * -1 - width), 100cqh - top)
    to: `min(calc(${LEFT} * -1), ${BOTTOM})`
  },
  'bottom-right': {
    // min(abs(left * -1 - width), abs(top * -1 - height))
    from: `min(calc(${LEFT} * -1), calc(${TOP} * -1))`,
    // min(100cqw - left, 100cqh - top)
    to: `min(${RIGHT}, ${BOTTOM})`
  }
};
const TRANSLATE_BY_DIRECTION_MAP = {
  left: {
    from: `${RIGHT} 0`,
    to: `${LEFT} 0`
  },
  right: {
    from: `${LEFT} 0`,
    to: `${RIGHT} 0`
  },
  top: {
    from: `0 ${BOTTOM}`,
    to: `0 ${TOP}`
  },
  bottom: {
    from: `0 ${TOP}`,
    to: `0 ${BOTTOM}`
  }
};
const GET_OFFSET_BY_DIRECTION_MAP = {
  // (width + left) / (100cqw + width)
  left: _ref => {
    let {
      left,
      width,
      parentWidth
    } = _ref;
    return (width + left) / (parentWidth + width || 1);
  },
  // (100cqw - left) / (100cqw + width)
  right: _ref2 => {
    let {
      left,
      width,
      parentWidth
    } = _ref2;
    return (parentWidth - left) / (parentWidth + width || 1);
  },
  // (100cqh - top) / (100cqh + height)
  bottom: _ref3 => {
    let {
      top,
      height,
      parentHeight
    } = _ref3;
    return (parentHeight - top) / (parentHeight + height || 1);
  },
  // (height + top) / (100cqh + height)
  top: _ref4 => {
    let {
      top,
      height,
      parentHeight
    } = _ref4;
    return (height + top) / (parentHeight + height || 1);
  },
  // min(<left>, <top>)
  'bottom-right': _ref5 => {
    let {
      left,
      top,
      width,
      height,
      parentWidth,
      parentHeight
    } = _ref5;
    const leftDistance = width + left;
    const topDistance = parentHeight - top;
    return leftDistance < topDistance ? leftDistance / (parentWidth + width || 1) : topDistance / (parentHeight + height || 1);
  },
  // min(<right>, <top>)
  'bottom-left': _ref6 => {
    let {
      left,
      top,
      width,
      height,
      parentWidth,
      parentHeight
    } = _ref6;
    const rightDistance = parentWidth - left;
    const topDistance = parentHeight - top;
    return rightDistance < topDistance ? rightDistance / (parentWidth + width || 1) : topDistance / (parentHeight + height || 1);
  },
  // min(<left>, <bottom>)
  'top-right': _ref7 => {
    let {
      left,
      top,
      width,
      height,
      parentWidth,
      parentHeight
    } = _ref7;
    const leftDistance = parentWidth - left;
    const bottomDistance = height + top;
    return leftDistance < bottomDistance ? leftDistance / (parentWidth + width || 1) : bottomDistance / (parentHeight + height || 1);
  },
  // min(<right>, <bottom>)
  'top-left': _ref8 => {
    let {
      left,
      top,
      width,
      height,
      parentWidth,
      parentHeight
    } = _ref8;
    const rightDistance = parentWidth - left;
    const bottomDistance = height + top;
    return rightDistance < bottomDistance ? rightDistance / (parentWidth + width || 1) : bottomDistance / (parentHeight + height || 1);
  }
};
function generateTranslate(direction) {
  const _from = FOUR_CORNERS_TRANSLATIONS[direction].from;
  const _to = FOUR_CORNERS_TRANSLATIONS[direction].to;
  const fromYFactor = direction.startsWith('top') ? 1 : -1;
  const toYFactor = -fromYFactor;
  const fromXFactor = direction.endsWith('left') ? 1 : -1;
  const toXFactor = -fromXFactor;
  return {
    from: `calc(${_from} * ${fromXFactor}) calc(${_from} * ${fromYFactor})`,
    to: `calc(${_to} * ${toXFactor}) calc(${_to} * ${toYFactor})`
  };
}
export default function create(options, dom) {
  const {
    direction = 'right'
  } = options.namedEffect;
  const duration = options.duration || 0;
  const delay = options.delay || 0;
  const durationPart = duration / (duration + delay || 1);
  let left = 0;
  let top = 0;
  let width = 0;
  let height = 0;
  let parentWidth = 0;
  let parentHeight = 0;
  if (dom) {
    dom.measure(target => {
      if (!target) {
        return;
      }
      const {
        width: targetWidth,
        height: targetHeight
      } = target.getBoundingClientRect();
      const parent = target.offsetParent;
      const parentRect = (parent == null ? void 0 : parent.getBoundingClientRect()) || {};
      const offset = getElementOffset(target, parent);
      left = offset.left;
      top = offset.top;
      width = targetWidth;
      height = targetHeight;
      parentWidth = parentRect.width;
      parentHeight = parentRect.height;
    });
    dom.mutate(target => {
      target == null || target.style.setProperty('--motion-left', `${left}px`);
      target == null || target.style.setProperty('--motion-top', `${top}px`);
      target == null || target.style.setProperty('--motion-width', `${width}px`);
      target == null || target.style.setProperty('--motion-height', `${height}px`);
      target == null || target.style.setProperty('--motion-parent-width', `${parentWidth}px`);
      target == null || target.style.setProperty('--motion-parent-height', `${parentHeight}px`);
    });
  }
  return [{
    ...options,
    delay: 0,
    easing: 'linear',
    duration: duration + delay,
    get keyframes() {
      // (100cqw - left) / (100cqw + 100%) * (duration / (duration + delay))
      const toDurationOffset = GET_OFFSET_BY_DIRECTION_MAP[direction]({
        left,
        top,
        width,
        height,
        parentWidth,
        parentHeight
      }) * durationPart;
      let from, to;
      if (direction in TRANSLATE_BY_DIRECTION_MAP) {
        from = TRANSLATE_BY_DIRECTION_MAP[direction].from;
        to = TRANSLATE_BY_DIRECTION_MAP[direction].to;
      } else {
        const cornerFromTo = generateTranslate(direction);
        from = cornerFromTo.from;
        to = cornerFromTo.to;
      }
      return [{
        offset: 0,
        translate: '0 0'
      }, {
        offset: toDurationOffset,
        translate: to,
        easing: 'step-start'
      }, {
        offset: toDurationOffset,
        translate: from
      }, {
        offset: duration / (duration + delay || 1),
        translate: '0 0'
      }, {
        offset: 1,
        translate: '0 0'
      }];
    }
  }];
  /*
   * @keyframes <name> {
   *   0% {
   *     translate: 0 0;
   *   }
   *   <toDurationOffset * 100%> {
   *     translate: <to>;
   *     easing: step-start;
   *   }
   *   <(toDurationOffset + 0.0001) * 100%> {
   *     translate: <from>;
   *   }
   *   <(1 - delay / (duration + delay)) * 100%> {
   *     translate: 0 0;
   *   }
   *   100% {
   *     translate: 0 0;
   *   }
   * }
   *
   * #target {
   *   animation: <name> <duration + delay> 0s linear infinite;
   * }
   */
}
//# sourceMappingURL=Cross.js.map