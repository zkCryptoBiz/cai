import { getCssUnits, getEasing, getEasingFamily } from '../../utils';
const DIRECTION_MAP = {
  vertical: 'translateY',
  horizontal: 'translateX',
  center: 'translateZ'
};
function getDistance(_ref, multiplier) {
  let {
    value,
    type = 'px'
  } = _ref;
  if (multiplier === void 0) {
    multiplier = 1;
  }
  const distance = value * multiplier;
  const units = getCssUnits(type);
  return `${distance}${units}`;
}
function getDelaySequence(distance, duration) {
  return [{
    frameTravel: getDistance(distance),
    frameTime: duration / 4
  }, {
    frameTravel: getDistance(distance, -1),
    frameTime: duration / 2
  }, {
    frameTravel: getDistance(distance),
    frameTime: duration / 2
  }, {
    frameTravel: getDistance(distance, -0.7),
    frameTime: duration / 2
  }, {
    frameTravel: getDistance(distance, 0.6),
    frameTime: duration / 3
  }];
}
export default function create(options) {
  const {
    direction = 'vertical',
    distance = {
      value: 25,
      type: 'px'
    }
  } = options.namedEffect;
  const easing = options.easing || 'sineInOut';
  const duration = options.duration || 0;
  const delay = options.delay || 0;
  const transformAxis = DIRECTION_MAP[direction];
  const travel = getDistance(distance);
  const ease = getEasingFamily(easing);
  const totalDurationWithDelay = 3.2 * duration + delay;
  const delaySequence = getDelaySequence(distance, duration);
  const perspectiveTransform = direction === 'center' ? 'perspective(800px) ' : '';
  let currentOffset = 0;

  // in case a delay is applied, animate a different sequence which decays to a stop
  const keyframes = delay ? delaySequence.map(_ref2 => {
    let {
      frameTravel,
      frameTime
    } = _ref2;
    const keyframeOffset = currentOffset + frameTime / totalDurationWithDelay;
    currentOffset = keyframeOffset;
    return {
      offset: keyframeOffset,
      easing: getEasing(ease.inOut),
      transform: `${perspectiveTransform}${[transformAxis]}(${frameTravel}) rotateZ(var(--comp-rotate-z, 0deg))`
    };
  }) : [{
    offset: 0.25,
    easing: getEasing(ease.inOut),
    transform: `${perspectiveTransform} ${[transformAxis]}(${travel}) rotateZ(var(--comp-rotate-z, 0deg))`
  }, {
    offset: 0.75,
    easing: getEasing(ease.in),
    transform: `${perspectiveTransform}${[transformAxis]}(-${travel}) rotateZ(var(--comp-rotate-z, 0deg))`
  }];
  return [{
    ...options,
    easing: 'linear',
    delay: 0,
    duration: delay ? totalDurationWithDelay : duration,
    keyframes: [{
      offset: 0,
      easing: getEasing(ease.out),
      transform: `${perspectiveTransform} ${[transformAxis]}(0) rotateZ(var(--comp-rotate-z, 0deg))`
    }, ...keyframes, {
      offset: 1,
      transform: `${perspectiveTransform} ${[transformAxis]}(0) rotateZ(var(--comp-rotate-z, 0deg))`
    }]
  }];
  /*
   *
   * @keyframes <name> {
   *   0% {
   *     transform: perspective(800px) rotateX/rotateY(0deg) rotateZ(<rotation>deg)
   *   }
   *   <duration / (duration + delay)> {
   *     transform: perspective(800px) rotateX/rotateY(360deg) rotateZ(<rotation>deg)
   *   }
   *   100% {
   *     transform: perspective(800px) rotateX/rotateY(360deg) rotateZ(<rotation>deg)
   *   }
   * }
   *
   *
   * #target {
   *   animation: <name> <duration + delay> 0s <easing> infinite;
   * }
   */
}
//# sourceMappingURL=Breathe.js.map