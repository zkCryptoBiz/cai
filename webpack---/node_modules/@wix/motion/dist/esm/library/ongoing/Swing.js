import { getEasing, getEasingFamily } from '../../utils';
const POWER_TO_SWING_FACTOR_MAP = {
  soft: 1,
  medium: 2,
  hard: 3
};
const DIRECTION_MAP = {
  top: {
    transAxis: 'translateY',
    transValue: -50
  },
  right: {
    transAxis: 'translateX',
    transValue: 50
  },
  bottom: {
    transAxis: 'translateY',
    transValue: 50
  },
  left: {
    transAxis: 'translateX',
    transValue: -50
  }
};
function getDelaySequence(swingDeg, timeToFrame) {
  return [{
    angle: swingDeg,
    frameTime: timeToFrame / 4
  }, {
    angle: -swingDeg,
    frameTime: timeToFrame / 2
  }, {
    angle: swingDeg * 0.6,
    frameTime: timeToFrame / 2
  }, {
    angle: swingDeg * -0.3,
    frameTime: timeToFrame / 2
  }, {
    angle: swingDeg * 0.2,
    frameTime: timeToFrame / 2
  }, {
    angle: swingDeg * -0.05,
    frameTime: timeToFrame / 2
  }, {
    angle: 0,
    frameTime: timeToFrame * 0.4
  }];
}
export default function create(options) {
  const {
    power,
    swing = 20,
    direction = 'top'
  } = options.namedEffect;
  const duration = options.duration || 0;
  const delay = options.delay || 0;
  const easing = options.easing || 'sineInOut';
  const ease = easing === 'linear' ? {
    in: 'linear',
    inOut: 'linear',
    out: 'linear'
  } : getEasingFamily(easing);
  const swingDeg = typeof power !== 'undefined' ? 20 * POWER_TO_SWING_FACTOR_MAP[power] : swing;
  const {
    transAxis,
    transValue
  } = DIRECTION_MAP[direction];
  const totalDuration = 3.55 * duration + delay;
  const delaySequence = getDelaySequence(swingDeg, duration);
  let currentOffset = 0;
  // in case a delay is applied, animate a different sequence which decays to a stop
  const keyframes = delay ? delaySequence.map(_ref => {
    let {
      angle,
      frameTime
    } = _ref;
    const keyframeOffset = currentOffset + frameTime / totalDuration;
    currentOffset = keyframeOffset;
    return {
      offset: keyframeOffset,
      easing: getEasing(ease.inOut),
      transform: `rotate(var(--comp-rotate-z, 0deg)) ${transAxis}(${transValue}%) rotate(${angle}deg) ${transAxis}(${-1 * transValue}%)`
    };
  }) : [{
    offset: 0.25,
    easing: getEasing(ease.inOut),
    transform: `rotate(var(--comp-rotate-z, 0deg)) ${transAxis}(${transValue}%) rotate(${+swingDeg}deg) ${transAxis}(${-1 * transValue}%)`
  }, {
    offset: 0.75,
    easing: getEasing(ease.in),
    transform: `rotate(var(--comp-rotate-z, 0deg)) ${transAxis}(${transValue}%) rotate(${-swingDeg}deg) ${transAxis}(${-1 * transValue}%)`
  }];
  return [{
    ...options,
    easing: 'linear',
    delay: 0,
    duration: delay ? totalDuration : duration,
    keyframes: [{
      offset: 0,
      easing: getEasing(ease.out),
      transform: `rotateZ(var(--comp-rotate-z, 0deg)) ${transAxis}(${transValue}%) rotate(0deg) ${transAxis}(${-1 * transValue}%)`
    }, ...keyframes, {
      offset: 1,
      transform: `rotateZ(var(--comp-rotate-z, 0deg)) ${transAxis}(${transValue}%) rotate(0deg) ${transAxis}(${-1 * transValue}%)`
    }]
  }];
  /*
   *
   * @keyframes <name> {
   *   0% {
   *     transform: rotateX/rotateY(0deg) rotateZ(<rotation>deg)
   *   }
   *   <duration / (duration + delay)> {
   *     transform: rotateX/rotateY(360deg) rotateZ(<rotation>deg)
   *   }
   *   100% {
   *     transform: rotateX/rotateY(360deg) rotateZ(<rotation>deg)
   *   }
   * }
   *
   *
   * #target {
   *   animation: <name> <duration + delay> <easing> infinite;
   * }
   */
}
//# sourceMappingURL=Swing.js.map