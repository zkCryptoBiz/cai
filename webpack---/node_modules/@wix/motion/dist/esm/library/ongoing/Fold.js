import { getEasing, getEasingFamily } from '../../utils';
const POWER_TO_ROTATION_FACTOR_MAP = {
  soft: 1,
  medium: 2,
  hard: 3
};
const DIRECTION_MAP = {
  top: {
    rotationAxis: 'rotateX',
    origin: {
      x: 0,
      y: -50
    }
  },
  right: {
    rotationAxis: 'rotateY',
    origin: {
      x: 50,
      y: 0
    }
  },
  bottom: {
    rotationAxis: 'rotateX',
    origin: {
      x: 0,
      y: 50
    }
  },
  left: {
    rotationAxis: 'rotateY',
    origin: {
      x: -50,
      y: 0
    }
  }
};
const MIN_ROTATE_ANGLE = 15;
function getDelaySequence(angle, duration) {
  return [{
    fold: angle,
    frameTime: duration / 4
  }, {
    fold: angle * -0.7,
    frameTime: duration / 2
  }, {
    fold: angle * 0.6,
    frameTime: duration / 2
  }, {
    fold: angle * -0.3,
    frameTime: duration * 0.45
  }, {
    fold: angle * 0.2,
    frameTime: duration * 0.4
  }, {
    fold: angle * -0.05,
    frameTime: duration / 2
  }, {
    fold: 0,
    frameTime: duration * 0.35
  }];
}
export default function create(options) {
  const {
    direction = 'top',
    power,
    angle = MIN_ROTATE_ANGLE
  } = options.namedEffect;
  const easing = options.easing || 'cubicInOut';
  const duration = options.duration || 0;
  const delay = +(options.delay || 0);
  const isResponsive = typeof power === 'undefined';
  const {
    rotationAxis,
    origin
  } = DIRECTION_MAP[direction];
  const {
    x,
    y
  } = origin;
  const ease = getEasingFamily(isResponsive ? easing : 'cubicInOut');
  const rotateTransform = isResponsive ? angle : MIN_ROTATE_ANGLE * POWER_TO_ROTATION_FACTOR_MAP[power];
  const totalDurationWithDelay = 3.2 * duration + delay;
  let currentOffset = 0;
  const transformLeft = `rotateZ(var(--comp-rotate-z, 0deg)) translateX(${x}%) translateY(${y}%) perspective(800px)`;
  const transformRight = `translateX(${-x}%) translateY(${-y}%)`;
  const getTransform = value => `${transformLeft} ${[rotationAxis]}(${value}deg) ${transformRight}`;

  // in case a delay is applied, animate a different sequence which decays to a stop
  const keyframes = delay ? getDelaySequence(rotateTransform, duration).map(_ref => {
    let {
      fold,
      frameTime
    } = _ref;
    const keyframeOffset = currentOffset + frameTime / totalDurationWithDelay;
    currentOffset = keyframeOffset;
    return {
      offset: keyframeOffset,
      easing: getEasing('sineInOut'),
      transform: getTransform(fold)
    };
  }) : [{
    offset: 0.25,
    easing: getEasing(ease.inOut),
    transform: getTransform(rotateTransform)
  }, {
    offset: 0.75,
    easing: getEasing(ease.in),
    transform: getTransform(-rotateTransform)
  }];
  const transform_0 = getTransform(0);
  return [{
    ...options,
    easing: 'linear',
    delay: 0,
    duration: delay ? totalDurationWithDelay : duration,
    keyframes: [{
      offset: 0,
      easing: getEasing(ease.out),
      transform: transform_0
    }, ...keyframes, {
      offset: 1,
      transform: transform_0
    }]
  }];
  /*
   *
   * @keyframes <name> {
   *   0% {
   *     transform: perspective(800px) rotateX/rotateY(0deg) rotateZ(<rotation>deg);
   *   }
   *   <duration / (duration + delay)> {
   *     transform: perspective(800px) rotateX/rotateY(360deg) rotateZ(<rotation>deg);
   *   }
   *   100% {
   *     transform: perspective(800px) rotateX/rotateY(360deg) rotateZ(<rotation>deg);
   *   }
   * }
   *
   *
   * #target {
   *   animation: <name> <duration + delay> 0s <easing> infinite;
   * }
   */
}
//# sourceMappingURL=Fold.js.map