import { getAdjustedDirection, getClipPolygonParams } from '../../utils';
const DIRECTIONS = ['bottom', 'left', 'top', 'right'];
const OPPOSITE_DIRECTION_MAP = {
  top: 'bottom',
  bottom: 'top',
  left: 'right',
  right: 'left'
};
const DIRECTION_TRANSLATION_MAP = {
  top: {
    x: '0',
    y: '-100%'
  },
  right: {
    x: '100%',
    y: '0'
  },
  bottom: {
    x: '0',
    y: '100%'
  },
  left: {
    x: '-100%',
    y: '0'
  }
};
const initialClip = getClipPolygonParams({
  direction: 'initial'
});
const KEYFRAMES_RANGE_MAP = {
  in: (clip, translate) => [{
    clipPath: `var(--motion-clip-from, ${clip.from})`,
    transform: `rotate(var(--comp-rotate-z, 0)) translate(${translate.from.x}, ${translate.from.y})`
  }, {
    clipPath: initialClip,
    transform: `rotate(var(--comp-rotate-z, 0)) translate(0, 0)`
  }],
  out: (clip, translate) => [{
    clipPath: initialClip,
    transform: `rotate(var(--comp-rotate-z, 0)) translate(0, 0)`
  }, {
    clipPath: `var(--motion-clip-from, ${clip.from})`,
    transform: `rotate(var(--comp-rotate-z, 0)) translate(${translate.from.x}, ${translate.from.y})`
  }],
  continuous: (clip, translate) => [{
    clipPath: `var(--motion-clip-from, ${clip.from})`,
    transform: `rotate(var(--comp-rotate-z, 0)) translate(${translate.from.x}, ${translate.from.y})`
  }, {
    clipPath: initialClip,
    transform: `rotate(var(--comp-rotate-z, 0)) translate(0, 0)`
  }, {
    clipPath: `var(--motion-clip-to, ${clip.to})`,
    transform: `rotate(var(--comp-rotate-z, 0)) translate(${translate.to.x}, ${translate.to.y})`
  }]
};
export default function create(options, dom) {
  const {
    direction = 'bottom',
    range = 'in'
  } = options.namedEffect;
  const easing = 'linear';
  const fill = range === 'out' ? 'forwards' : range === 'in' ? 'backwards' : options.fill;
  const oppositeDirection = OPPOSITE_DIRECTION_MAP[direction];
  const keyframes = KEYFRAMES_RANGE_MAP[range]({
    from: getClipPolygonParams({
      direction: oppositeDirection
    }),
    to: getClipPolygonParams({
      direction
    })
  }, {
    from: DIRECTION_TRANSLATION_MAP[direction],
    to: DIRECTION_TRANSLATION_MAP[oppositeDirection]
  });
  if (dom) {
    dom.measure(target => {
      if (!target) {
        return;
      }
      const rotation = parseInt(getComputedStyle(target).getPropertyValue('--comp-rotate-z') || '0', 10);
      dom.mutate(() => {
        const adjDirection = getAdjustedDirection(DIRECTIONS, direction, rotation);
        target.style.setProperty('--motion-clip-from', getClipPolygonParams({
          direction: OPPOSITE_DIRECTION_MAP[adjDirection]
        }));
        target.style.setProperty('--motion-clip-to', getClipPolygonParams({
          direction: adjDirection
        }));
      });
    });
  }
  return [{
    ...options,
    fill,
    easing,
    keyframes
  }];
  /*
   * @keyframes <name> {
   *   from {
   *     clip-path: <clip.from>;
   *     translate: <translate.from.x> <translate.from.y>;
   *   }
   *   to {
   *     clip-path: none;
   *     translate: 0 0;
   *   }
   * }
   */
}
//# sourceMappingURL=SlideScroll.js.map