import { getCssUnits, getOutOfScreenDistance } from '../../utils';
const EASING_MAP = {
  soft: 'cubicInOut',
  medium: 'quintInOut',
  hard: 'backOut'
};
export default function create(options, dom) {
  const {
    direction = 270,
    distance = {
      value: 100,
      type: 'percentage'
    },
    power,
    startFromOffScreen = false
  } = options.namedEffect;
  const angleInRad = direction * Math.PI / 180;
  const unit = getCssUnits(distance.type);
  let left = 0;
  let top = 0;
  if (dom && startFromOffScreen) {
    dom.measure(target => {
      if (!target) {
        return;
      }
      const {
        left: targetLeft,
        top: targetTop
      } = target.getBoundingClientRect();
      left = targetLeft;
      top = targetTop;
    });
    dom.mutate(target => {
      target == null || target.style.setProperty('--motion-left', `${left}px`);
      target == null || target.style.setProperty('--motion-top', `${top}px`);
    });
  }
  const easing = power && EASING_MAP[power] || options.easing || 'quintInOut';
  const {
    x,
    y
  } = getOutOfScreenDistance(direction - 90);
  const translateX = startFromOffScreen ? x : `${Math.sin(angleInRad) * distance.value | 0}${unit}`;
  const translateY = startFromOffScreen ? y : `${Math.cos(angleInRad) * distance.value * -1 | 0}${unit}`;
  return [{
    ...options,
    easing,
    keyframes: [{
      opacity: 'var(--comp-opacity, 1)',
      translate: `${translateX} ${translateY}`
    }, {
      opacity: 'var(--comp-opacity, 1)',
      translate: '0 0'
    }]
  }];

  /*
   * @keyframes <name> {
   *   from {
   *     opacity: var(--comp-opacity, 1);
   *     translate: <x> <y>;
   *   }
   *   to {
   *     opacity: var(--comp-opacity, 1);
   *     translate: 0 0;
   *   }
   * }
   *
   * #target {
   *   animation: <name> <duration> <delay> <easing> backwards;
   * }
   */
}
//# sourceMappingURL=GlitchIn.js.map