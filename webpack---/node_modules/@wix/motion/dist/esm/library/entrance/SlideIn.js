import { getAdjustedDirection, getClipPolygonParams } from '../../utils';
const PARAM_MAP = {
  top: {
    dx: 0,
    dy: -1,
    clip: 'bottom'
  },
  right: {
    dx: 1,
    dy: 0,
    clip: 'left'
  },
  bottom: {
    dx: 0,
    dy: 1,
    clip: 'top'
  },
  left: {
    dx: -1,
    dy: 0,
    clip: 'right'
  }
};
const DIRECTIONS = ['top', 'right', 'bottom', 'left'];
const INITIAL_TRANSLATE_MAP = {
  soft: 0.2,
  medium: 0.8,
  hard: 1
};
export default function create(options, dom) {
  const {
    direction = 'left',
    power,
    initialTranslate = 1
  } = options.namedEffect;
  const easing = options.easing || 'cubicInOut';
  const scale = power && INITIAL_TRANSLATE_MAP[power] || initialTranslate;
  const minimum = 100 - scale * 100;
  const start = getClipPolygonParams({
    direction,
    minimum
  });
  if (dom) {
    dom.measure(target => {
      if (!target) {
        return;
      }
      const rotation = parseInt(getComputedStyle(target).getPropertyValue('--comp-rotate-z') || '0deg', 10);
      dom.mutate(target_ => {
        const adjustedDirection = getAdjustedDirection(DIRECTIONS, direction, rotation);
        target_ == null || target_.style.setProperty('--motion-clip-path', getClipPolygonParams({
          direction: PARAM_MAP[adjustedDirection].clip,
          minimum
        }));
        target_ == null || target_.style.setProperty('--motion-translate-x', `${PARAM_MAP[adjustedDirection].dx * 100}%`);
        target_ == null || target_.style.setProperty('--motion-translate-y', `${PARAM_MAP[adjustedDirection].dy * 100}%`);
      });
    });
  }
  const end = getClipPolygonParams({
    direction: 'initial'
  });
  const baseFade = {
    ...options,
    easing: 'cubicInOut',
    keyframes: [{
      opacity: 0
    }, {
      opacity: 'var(--comp-opacity, 1)'
    }]
  };
  return [{
    ...options,
    easing,
    keyframes: [{
      transform: `rotate(var(--comp-rotate-z, 0deg)) translate(var(--motion-translate-x, -100%), var(--motion-translate-y, 0%))`,
      clipPath: `var(--motion-clip-path, ${start})`
    }, {
      transform: 'rotate(var(--comp-rotate-z, 0deg)) translate(0px, 0px)',
      clipPath: end
    }]
  }, ...(power !== 'hard' ? [baseFade] : [])];

  /*
   *
   * @keyframes <name> {
   *   from {
   *     translate: <x> <y>
   *     clip-path: <start>
   *   }
   *   to {
   *     translate: 0 0
   *     clip-path: <end>
   *   }
   * }
   *
   * #target {
   *   animation: <name>-clip <duration> <delay> <easing> backwards;
   * }
   */
}
//# sourceMappingURL=SlideIn.js.map