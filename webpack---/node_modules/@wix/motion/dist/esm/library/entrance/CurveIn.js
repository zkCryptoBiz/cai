const PARAMS_MAP = {
  pseudoRight: {
    rotationX: '180',
    rotationY: '0'
  },
  right: {
    rotationX: '0',
    rotationY: '180'
  },
  pseudoLeft: {
    rotationX: '-180',
    rotationY: '0'
  },
  left: {
    rotationX: '0',
    rotationY: '-180'
  }
};
export default function create(options, dom) {
  const {
    direction = 'right'
  } = options.namedEffect;
  const {
    rotationX,
    rotationY
  } = PARAMS_MAP[direction];
  if (dom) {
    dom.measure(target => {
      if (!target) {
        return;
      }
      const width = target.getBoundingClientRect().width;
      dom.mutate(target_ => {
        target_ == null || target_.style.setProperty('--motion-width', `${width}px`);
      });
    });
  }
  return [{
    ...options,
    easing: 'quadOut',
    keyframes: [{
      opacity: 0,
      transform: `perspective(200px) translateZ(calc(var(--motion-width, 300px) * -3)) rotateX(${rotationX}deg) rotateY(${rotationY}deg) translateZ(calc(var(--motion-width, 300px) * 3)) rotateZ(var(--comp-rotate-z, 0deg))`
    }, {
      opacity: 'var(--comp-opacity, 1)',
      transform: `perspective(200px) translateZ(calc(var(--motion-width, 300px) * -3)) rotateX(0deg) rotateY(0deg) translateZ(calc(var(--motion-width, 300px) * 3)) rotateZ(var(--comp-rotate-z, 0deg))`
    }]
  }];

  /*
   *
   * @keyframes <name> {
   *   from {
   *   opacity: 0;
   *    transform: perspective(200px) translateZ(calc(var(<width>, 300px) * -1.5)) rotateX(<rotationX>deg) rotateY(<rotationY>deg) translateZ(calc(var(<width>, 300px) * 1.5)) rotateZ(var(--comp-rotate-z, 0deg));
   *   }
   *   to {
   *     opacity: 1;
   *     transform: perspective(200px) translateZ(calc(var(<width>, 300px) * -1.5)) rotateX(0deg) rotateY(0deg) translateZ(calc(var(<width>, 300px) * 1.5)) rotateZ(var(--comp-rotate-z, 0deg))
   *   }
   * }
   *
   * #target {
   *   animation: <name> <duration> <delay> quadOut backwards;
   * }
   */
}
//# sourceMappingURL=CurveIn.js.map