import { getAdjustedDirection, getClipPolygonParams } from '../../utils';
const ROTATION_MAP = {
  left: 30,
  right: -30
};
const DIRECTIONS = ['top', 'right', 'bottom', 'left'];
function getClipStart(rotateZ) {
  const clipDirection = getAdjustedDirection(DIRECTIONS, 'top', rotateZ);
  return getClipPolygonParams({
    direction: clipDirection,
    minimum: 0
  });
}
export default function create(options, dom) {
  const {
    direction = 'left'
  } = options.namedEffect;
  const easing = options.easing || 'cubicOut';
  const start = getClipStart(0);
  const rotationZ = ROTATION_MAP[direction];
  const end = getClipPolygonParams({
    direction: 'initial'
  });
  const translateZ = `calc(var(--motion-height, 200px) / 2)`;
  if (dom) {
    dom.measure(target => {
      if (!target) {
        return;
      }
      const height = target.getBoundingClientRect().height;
      const rotation = getComputedStyle(target).getPropertyValue('--comp-rotate-z') || '0deg';
      dom.mutate(target_ => {
        target_ == null || target_.style.setProperty('--motion-height', `${height}px`);
        target_ == null || target_.style.setProperty('--motion-clip-path', getClipStart(parseInt(rotation, 10)));
      });
    });
  }
  return [{
    ...options,
    duration: options.duration * 0.2,
    easing: 'cubicOut',
    keyframes: [{
      opacity: 0
    }, {
      opacity: 'var(--comp-opacity, 1)'
    }]
  }, {
    ...options,
    easing,
    keyframes: [{
      transform: ` perspective(800px) translateZ(calc(${translateZ} * -1)) rotateX(-90deg) translateZ(${translateZ}) rotate(var(--comp-rotate-z, 0deg))`
    }, {
      transform: ` perspective(800px) translateZ(calc(${translateZ} * -1)) rotateX(0deg) translateZ(${translateZ}) rotate(var(--comp-rotate-z, 0deg))`
    }]
  }, {
    ...options,
    easing,
    composite: 'add',
    duration: options.duration * 0.8,
    keyframes: [{
      clipPath: `var(--motion-clip-path, ${start})`,
      transform: `rotateZ(${rotationZ}deg)`
    }, {
      clipPath: end,
      transform: `rotateZ(0deg)`
    }]
  }];

  /*
   * * @keyframes <name>-fade {
   *   from {
   *     opacity: 0
   *   }
   *   to {
   *     opacity: 1
   *   }
   * }
   *
   * @keyframes <name>-rotate {
   *   from {
   *    transform: rotateZ(<rotationZ>deg);
   *   }
   *   to {
   *    transform: rotateZ(0deg);
   *   }
   * }
   *
   * @keyframes <name>-tilt {
   *   from {
   *    transform: perspective(800px) translateZ(${-translateZ}) rotateX(-90deg) translateZ(${translateZ}) rotate(var(--comp-rotate-z, 0deg));
   *   }
   *   to {
   *    transform: perspective(800px) translateZ(${-translateZ}) rotateX(0deg) translateZ(${translateZ}) rotate(var(--comp-rotate-z, 0deg));
   *   }
   * }
   *
   * #target {
   *   animation: <name>-fade <duration * 0.2> <delay> cubicOut backwards,
   *              <name>-tilt <duration> <delay> <easing> backwards,
   *              <name>-rotate <duration * 0.8> <delay> <easing> backwards;
   *   animation-composition: replace, replace, add;
   * }
   */
}
//# sourceMappingURL=TiltIn.js.map