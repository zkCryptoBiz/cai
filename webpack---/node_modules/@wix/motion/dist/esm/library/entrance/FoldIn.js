import { getAdjustedDirection } from '../../utils';
const POWER_TO_ROTATE_MAP = {
  soft: 35,
  medium: 60,
  hard: 90
};
const DIRECTIONS = ['top', 'right', 'bottom', 'left'];
const PARAM_MAP = {
  top: {
    x: -1,
    y: 0,
    origin: {
      x: 0,
      y: -50
    }
  },
  right: {
    x: 0,
    y: -1,
    origin: {
      x: 50,
      y: 0
    }
  },
  bottom: {
    x: 1,
    y: 0,
    origin: {
      x: 0,
      y: 50
    }
  },
  left: {
    x: 0,
    y: 1,
    origin: {
      x: -50,
      y: 0
    }
  }
};
function getRotateFrom(direction, rotate) {
  return {
    x: PARAM_MAP[direction].x * rotate,
    y: PARAM_MAP[direction].y * rotate
  };
}
export default function create(options, dom) {
  const {
    direction = 'top',
    power,
    initialRotate = 90
  } = options.namedEffect;
  const easing = options.easing || 'backOut';
  const rotate = power && POWER_TO_ROTATE_MAP[power] || initialRotate;
  const {
    x,
    y
  } = PARAM_MAP[direction].origin;
  const from = getRotateFrom(direction, rotate);
  if (dom) {
    dom.measure(target => {
      if (!target) {
        return;
      }
      const rotation = getComputedStyle(target).getPropertyValue('--comp-rotate-z') || '0deg';
      const adjustedDirection = getAdjustedDirection(DIRECTIONS, direction, parseInt(rotation, 10));
      dom.mutate(() => {
        const {
          origin
        } = PARAM_MAP[adjustedDirection];
        const newRotate = getRotateFrom(adjustedDirection, rotate);
        target == null || target.style.setProperty('--motion-origin-x', `${origin.x}%`);
        target == null || target.style.setProperty('--motion-origin-y', `${origin.y}%`);
        target == null || target.style.setProperty('--motion-rotate-x', `${newRotate.x}deg`);
        target == null || target.style.setProperty('--motion-rotate-y', `${newRotate.y}deg`);
      });
    });
  }
  return [{
    ...options,
    easing: 'quadOut',
    keyframes: [{
      opacity: 0
    }, {
      opacity: 'var(--comp-opacity, 1)'
    }]
  }, {
    ...options,
    easing,
    keyframes: [{
      transform: `rotate(var(--comp-rotate-z, 0deg)) translate(var(--motion-origin-x ,${x}%), var(--motion-origin-y, ${y}%)) perspective(800px) rotateX(var(--motion-rotate-x, ${from.x}deg)) rotateY(var(--motion-rotate-y, ${from.y}deg)) translate(calc(-1 * var(--motion-origin-x ,${x}%)), calc(-1 * var(--motion-origin-y, ${y}%)))`
    }, {
      transform: `rotate(var(--comp-rotate-z, 0deg)) translate(var(--motion-origin-x ,${x}%), var(--motion-origin-y, ${y}%)) perspective(800px) rotateX(0deg) rotateY(0deg) translate(calc(-1 * var(--motion-origin-x ,${x}%)), calc(-1 * var(--motion-origin-y, ${y}%)))`
    }]
  }];

  /*
   * * @keyframes <name>-fade {
   *   from {
   *     opacity: 0
   *   }
   *   to {
   *     opacity: 1
   *   }
   * }
   *
   * @keyframes <name>-fold {
   *   from {
   *    transform: rotate(<comp-rotate-z>) translate(<rotateOriginX>, <rotateOriginY>) perspective(800px) <rotateTransform>(<from[rotateTransform]>deg) translate(-<rotateOriginX>, -<rotateOriginY>);
   *   }
   *   to {
   *     transform: rotate(<comp-rotate-z>) translate(<rotateOriginX>, <rotateOriginY>) perspective(800px) <rotateTransform>(0deg) translate(-<rotateOriginX>, -<rotateOriginY>);
   *   }
   * }
   *
   *
   *
   *
   * #target {
   *   animation: <name>-fold <duration> <delay> <easing> backwards,
   *              <name>-fade <duration> <delay> quadOut backwards;
   * }
   */
}
//# sourceMappingURL=FoldIn.js.map