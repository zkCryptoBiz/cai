import { deg2rad } from '@wix/wow-utils';
import { getAdjustedDirection, getElementTransformedPosition, } from '../../../utils/animationsUtils';
const name = 'ShrinkScroll';
const properties = {
    schema: {},
};
const MAX_Y_TRAVEL = 40;
const powerMap = {
    soft: { scaleFrom: 1.2, scaleTo: 0.8, travelY: 0 },
    medium: { scaleFrom: 1.7, scaleTo: 0.3, travelY: 0.5 },
    hard: { scaleFrom: 3.5, scaleTo: 0, travelY: 1 },
};
const directionMap = {
    top: { origin: '50% 0', idx: 0 },
    'top-right': { origin: '100% 0', idx: 1 },
    right: { origin: '100% 50%', idx: 2 },
    'bottom-right': { origin: '100% 100%', idx: 3 },
    bottom: { origin: '50% 100%', idx: 4 },
    'bottom-left': { origin: '0 100%', idx: 5 },
    left: { origin: '0 50%', idx: 6 },
    'top-left': { origin: '0 0', idx: 7 },
    // center: { origin: '50% 50%' },
};
const rangeValues = {
    in: (scaleFrom, _scaleTo, travelY) => ({
        fromValues: { scale: scaleFrom, travel: travelY },
        toValues: { scale: 1, travel: 0 },
        scaleDuration: 1000,
        scaleEase: 'sineIn',
    }),
    out: (_scaleFrom, scaleTo, travelY) => ({
        fromValues: { scale: 1, travel: 0 },
        toValues: { scale: scaleTo, travel: -travelY },
        scaleDuration: 370,
        scaleEase: 'sineOut',
    }),
    continuous: (scaleFrom, scaleTo, travelY) => ({
        fromValues: { scale: scaleFrom, travel: travelY },
        toValues: { scale: scaleTo, travel: -travelY },
        scaleDuration: 775,
        scaleEase: 'sineInOut',
    }),
};
/**
 * Shrink Scroll
 */
function animate(kit, elements, _duration, _delay, { power, range = 'in', scale = range === 'in' ? 1.2 : 0.8, direction = 'center', speed = 0, ...params } = {}) {
    const sequence = kit.sequence(params);
    const { scaleFrom, scaleTo, travelY } = typeof power !== 'undefined'
        ? powerMap[power]
        : {
            scaleFrom: scale,
            scaleTo: scale,
            travelY: speed,
        };
    const { fromValues, toValues, scaleDuration, scaleEase } = rangeValues[range](scaleFrom, scaleTo, travelY * -MAX_Y_TRAVEL);
    const duration = power === 'hard' ? scaleDuration : 1000;
    let yPositionOffset = 0; // rotated element's position is affected when changing direction (transform origin)
    if (direction !== 'center') {
        elements.forEach((element) => {
            const elementAngleInDeg = Number(element.getAttribute('data-angle')) || 0;
            let adjDirection = direction;
            adjDirection = getAdjustedDirection(directionMap, direction, elementAngleInDeg);
            const [trOriginX, trOriginY] = directionMap[adjDirection].origin.split(' ');
            const { x, y } = getElementTransformedPosition({ x: trOriginX, y: trOriginY }, kit.engine.getBoundingRect(element), deg2rad(elementAngleInDeg));
            const windowHeight = window.innerHeight; // Get the viewport height in pixels
            yPositionOffset = (y / windowHeight) * 100; // Get y offset in vh
            sequence.add(kit.engine.set(element, {
                x,
                y,
                transformOrigin: directionMap[adjDirection].origin,
            }));
        });
    }
    sequence.add([
        kit.animate('BaseScale', elements, duration, 0, {
            from: { scale: fromValues.scale },
            to: { scale: toValues.scale },
            ease: scaleEase,
        }),
        kit.animate('BasePosition', elements, 1000, 0, {
            from: { y: `${fromValues.travel + yPositionOffset}vh` },
            to: { y: `${toValues.travel + yPositionOffset}vh` },
            ease: 'linear',
        }),
    ]);
    return sequence.get();
}
const api = {
    getScrubOffsets({ power, range = 'in', speed = 0, }) {
        const offset = (typeof power !== 'undefined'
            ? powerMap[power].travelY
            : Math.abs(speed)) * MAX_Y_TRAVEL;
        return {
            start: range === 'out' ? '0px' : `${-offset}vh`,
            end: range === 'in' ? '0px' : `${offset}vh`,
        };
    },
};
export { name, properties, animate, api };
//# sourceMappingURL=shrinkScroll.js.map