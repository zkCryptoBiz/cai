// Flatten a nested object to params object { field: { text: 'foo' } } => { field.text ='foo' }
function flattenParams(data, path = '') {
    const params = {};
    Object.entries(data).forEach(([key, value]) => {
        const isObject = value !== null && typeof value === 'object' && !Array.isArray(value);
        const fieldPath = resolvePath(path, key);
        if (isObject) {
            const serializedObject = flattenParams(value, fieldPath);
            Object.assign(params, serializedObject);
        }
        else {
            params[fieldPath] = value;
        }
    });
    return params;
}
function resolvePath(path, key) {
    return `${path}${path ? '.' : ''}${key}`;
}
export function toURLSearchParams(params) {
    const flatten = flattenParams(params);
    return Object.entries(flatten).reduce((urlSearchParams, [key, value]) => {
        // inorder to make `foo: [1,2]` turn into `foo=1&foo=2` and not `foo[]=1&foo[]=2`
        const keyParams = Array.isArray(value) ? value : [value];
        keyParams.forEach((param) => {
            if (param === undefined || param === null) {
                return;
            }
            urlSearchParams.append(key, param);
        });
        return urlSearchParams;
    }, new URLSearchParams());
}
//# sourceMappingURL=flatten-params.js.map