import { isNil, isPlainObject, noop } from 'lodash';
import { pascalCase } from './utils/stringUtils';
import { createWidgetServices } from './widgetServices';
import { WidgetCreationError } from './errors/widgetCreationError';
import { isBlocksAppParams } from './utils';
function getCreateEventFN($w, createEvent) {
    return (event) => {
        if (createEvent) {
            return createEvent(event);
        }
        const { type, ...data } = event;
        return $w.createEvent(type, data);
    };
}
function withEventListeners(widgetApi, widgetMetaData, $w, createEvent) {
    widgetMetaData.events?.forEach(({ name }) => {
        widgetApi[`on${pascalCase(name)}`] = (cb) => $w.on(name, (event) => cb(createEvent(event)));
    });
    return widgetApi;
}
function mergeProps(baseProps = {}, overrideProps) {
    if (!overrideProps) {
        return baseProps;
    }
    return Object.entries(overrideProps).reduce((mergedProps, [propKey, overrideValue]) => {
        const value = baseProps[propKey];
        if (isPlainObject(value)) {
            mergedProps[propKey] = mergeProps(value, overrideValue);
        }
        else {
            mergedProps[propKey] = isNil(value) ? overrideValue : value;
        }
        return mergedProps;
    }, {});
}
const normalizeDefaultProps = (defaultProps = []) => {
    return defaultProps.reduce((normalizedObj, { name, defaultValue }) => {
        normalizedObj[name] = defaultValue;
        return normalizedObj;
    }, {});
};
function shouldInvokePropsChangedOnUpdateConfig({ appParams }) {
    if (isBlocksAppParams(appParams)) {
        return appParams.appData?.blocksConsumerData
            ?.invokePropsChangedOnUpdateConfig;
    }
    return false;
}
export async function createWidgetController(controllerConfig, widgetMetaData, createWidgetFn, options = {
    shouldAddInternalApi: true,
}) {
    const { $w, config } = controllerConfig;
    const normalizedDefaultProps = normalizeDefaultProps(widgetMetaData.properties);
    const mergedProps = mergeProps(config.props, normalizedDefaultProps);
    const { generate$widget, generateWidgetAPI, setProps } = createWidgetServices(mergedProps, options.shouldAddInternalApi);
    const $widget = generate$widget($w);
    let customPageReady = noop;
    let moduleExports = {};
    let updateWidgetViewState;
    let getWidgetViewStateAfterRefresh;
    try {
        const widgetController = await createWidgetFn({
            $widget,
            ...controllerConfig,
        });
        customPageReady = widgetController?.pageReady;
        moduleExports = widgetController?.exports;
        updateWidgetViewState = widgetController?.updateWidgetViewState;
        getWidgetViewStateAfterRefresh =
            widgetController?.getWidgetViewStateAfterRefresh;
    }
    catch (e) {
        throw new WidgetCreationError(e);
    }
    const widgetApiFactory = (createEvent) => {
        const initialWidgetApi = generateWidgetAPI($widget, moduleExports);
        return withEventListeners(initialWidgetApi, widgetMetaData, $w, getCreateEventFN($w, createEvent));
    };
    const updateConfig = (_scoped$w, newConfig) => {
        // We assume that newConfig.props is undefined if the widget was reset
        // In this case we should reset the props to the default values
        // Otherwise we should merge the new props with the existing ones
        const props = newConfig.props
            ? mergeProps(newConfig.props, $widget.props)
            : normalizedDefaultProps;
        setProps($widget, props);
    };
    return {
        pageReady(scoped$w) {
            return customPageReady(scoped$w);
        },
        updateConfig: shouldInvokePropsChangedOnUpdateConfig(controllerConfig)
            ? updateConfig
            : undefined,
        updateWidgetViewState,
        getWidgetViewStateAfterRefresh,
        exports: (_, createEvent) => widgetApiFactory(createEvent),
    };
}
//# sourceMappingURL=createWidgetController.js.map