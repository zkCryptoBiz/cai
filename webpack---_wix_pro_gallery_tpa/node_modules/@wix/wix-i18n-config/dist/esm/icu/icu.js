import IntlMessageFormat from 'intl-messageformat';
import * as utils from './utils';
function getDefaults() {
    return {
        memoize: true,
        memoizeFallback: false,
        bindI18n: '',
        bindI18nStore: undefined,
        parseErrorHandler: (_err, _key, res) => {
            return res;
        },
    };
}
/**
 * Copied from original ICU source code.
 * @source https://github.com/i18next/i18next-icu/blob/7809547c821a7ef3b2bb9ab2610cdbbcfedcb2f9/src/index.js
 *
 * It's done in order to support `IntlMessageFormat` out of the box.
 * `IntlMessageFormat` is adding formatters that are not provided by i18n.
 * For example, `select` formatter - https://formatjs.io/docs/core-concepts/icu-syntax#select-format
 * It allows to use following translation value: 'Welcome back{inputData, select, 0 {} 1 {, John}}'
 * See example in tests: __tests__/i18n.spec.tsx
 */
class ICU {
    constructor(options) {
        this.type = 'i18nFormat';
        this.mem = {};
        this.init(null, options);
    }
    init(i18next, options) {
        const i18nextOptions = (i18next && i18next.options && i18next.options.i18nFormat) || {};
        this.options = utils.defaults(i18nextOptions, options, this.options || {}, getDefaults());
        this.formats = this.options?.formats;
        if (i18next) {
            const { bindI18n, bindI18nStore, memoize } = this.options;
            // @ts-expect-error
            i18next.IntlMessageFormat = IntlMessageFormat;
            // @ts-expect-error
            i18next.ICU = this;
            if (memoize) {
                if (bindI18n) {
                    i18next.on(bindI18n, () => this.clearCache());
                }
                if (bindI18nStore) {
                    i18next.store.on(bindI18nStore, () => this.clearCache());
                }
            }
        }
        if (this.options?.localeData) {
            if (Object.prototype.toString.apply(this.options.localeData) ===
                '[object Array]') {
                this.options.localeData.forEach((ld) => this.addLocaleData(ld));
            }
            else {
                this.addLocaleData(this.options.localeData);
            }
        }
    }
    addLocaleData(data) {
        const locales = Array.isArray(data) ? data : [data];
        locales.forEach((localeData) => {
            if (localeData && localeData.locale) {
                // @ts-expect-error
                IntlMessageFormat.__addLocaleData(localeData);
            }
        });
    }
    addUserDefinedFormats(formats) {
        this.formats = this.formats ? { ...this.formats, ...formats } : formats;
    }
    parse(res, options, lng, ns, key, info) {
        const hadSuccessfulLookup = info && info.resolved && info.resolved.res;
        const memKey = this.options?.memoize && `${lng}.${ns}.${key.replace(/\./g, '###')}`;
        let fc;
        if (this.options?.memoize) {
            fc = utils.getPath(this.mem, memKey);
        }
        try {
            if (!fc) {
                fc = new IntlMessageFormat(res, lng, this.formats);
                if (this.options?.memoize &&
                    (this.options.memoizeFallback || !info || hadSuccessfulLookup)) {
                    utils.setPath(this.mem, memKey, fc);
                }
            }
            return fc.format(options);
        }
        catch (err) {
            return this.options?.parseErrorHandler?.(err, key, res, options);
        }
    }
    addLookupKeys(finalKeys) {
        // no additional keys needed for select or plural
        // so there is no need to add keys to that finalKeys array
        return finalKeys;
    }
    clearCache() {
        this.mem = {};
    }
}
// @ts-expect-error
ICU.type = 'i18nFormat';
export default ICU;
//# sourceMappingURL=icu.js.map