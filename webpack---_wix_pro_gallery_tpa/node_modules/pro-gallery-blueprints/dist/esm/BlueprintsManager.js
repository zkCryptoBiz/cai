import { __assign, __awaiter, __generator } from "tslib";
/* eslint-disable prettier/prettier */
import blueprints from './Blueprints';
import { GALLERY_CONSTS, viewModeWrapper } from 'pro-gallery-lib';
var BlueprintsManager = /** @class */ (function () {
    function BlueprintsManager(_a) {
        var id = _a.id;
        this.id = id + "'s blueprintsManager";
        this.currentState = {};
        this.existingBlueprint = {};
        this.lastBlueprintId = 0;
        this.cache = {};
        this.api = {};
        this.currentState.totalItemsCount = Infinity;
        this.onBlueprintReady = function () { };
        this.loopingItems = false;
    }
    BlueprintsManager.prototype.init = function (config) {
        this.api = config.api;
        this.currentState.totalItemsCount =
            (config && config.totalItemsCount) || this.currentState.totalItemsCount;
        viewModeWrapper.setDeviceType(config.deviceType);
    };
    BlueprintsManager.prototype.setCurrentBlueprint = function (id) {
        this.lastBlueprintId = id;
    };
    BlueprintsManager.prototype.createBlueprint = function (params) {
        if (params === void 0) { params = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var lastBlueprintId, _a, _createBlueprint, _b, blueprintManagerId, blueprint, changedParams, reasons, blueprintChanged, blueprintCreated;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        lastBlueprintId = Math.floor(Math.random() * 1000);
                        this.currentState.totalItemsCount =
                            params.totalItemsCount ||
                                (this.api.getTotalItemsCount && this.api.getTotalItemsCount()) ||
                                this.currentState.totalItemsCount;
                        this.currentState.isUsingCustomInfoElements =
                            params.isUsingCustomInfoElements ||
                                (this.api.isUsingCustomInfoElements &&
                                    this.api.isUsingCustomInfoElements()) ||
                                this.currentState.isUsingCustomInfoElements;
                        _a = [__assign({}, params)];
                        return [4 /*yield*/, this.completeParams(params)];
                    case 1:
                        params = __assign.apply(void 0, _a.concat([(_c.sent())]));
                        params = this.duplicateItemsForSlideshowLoopIfNeeded(params);
                        _createBlueprint = function (args) { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        this.setCurrentBlueprint(args.blueprintManagerId);
                                        if (!this.api.createBlueprintImp) return [3 /*break*/, 2];
                                        return [4 /*yield*/, this.api.createBlueprintImp(args)];
                                    case 1: return [2 /*return*/, _a.sent()];
                                    case 2: return [4 /*yield*/, blueprints.createBlueprint(args)];
                                    case 3: return [2 /*return*/, _a.sent()];
                                }
                            });
                        }); };
                        return [4 /*yield*/, _createBlueprint({
                                params: params,
                                lastParams: this.currentState,
                                existingBlueprint: this.existingBlueprint,
                                blueprintManagerId: this.id + lastBlueprintId,
                                isUsingCustomInfoElements: this.currentState.isUsingCustomInfoElements,
                            })];
                    case 2:
                        _b = _c.sent(), blueprintManagerId = _b.blueprintManagerId, blueprint = _b.blueprint, changedParams = _b.changedParams, reasons = _b.reasons;
                        if (blueprintManagerId !== this.lastBlueprintId)
                            return [2 /*return*/];
                        blueprintChanged = Object.values(changedParams).some(function (changedParam) { return !!changedParam; });
                        blueprintCreated = Object.keys(blueprint).length > 0;
                        this.updateLastParamsIfNeeded(params, changedParams, blueprintCreated);
                        blueprintCreated &&
                            this.api.onBlueprintReady &&
                            this.api.onBlueprintReady({ blueprint: blueprint, blueprintChanged: blueprintChanged, reasons: reasons });
                        return [2 /*return*/, (this.cache[params] = this.existingBlueprint = blueprint)]; // still returning for awaits... event is !blueprintCreated
                }
            });
        });
    };
    BlueprintsManager.prototype.getMoreItems = function (currentItemLength) {
        return __awaiter(this, void 0, void 0, function () {
            var items;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(currentItemLength < this.currentState.totalItemsCount)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.api.fetchMoreItems(currentItemLength)];
                    case 1:
                        // this.gettingMoreItems = true;
                        items = _a.sent();
                        if (items) {
                            this.createBlueprint({ items: items });
                            // work with the new items...
                        }
                        return [3 /*break*/, 3];
                    case 2:
                        if (this.existingBlueprint.options.slideshowLoop) {
                            this.duplicateItemsAndCreateBlueprint();
                        }
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    BlueprintsManager.prototype.resetItemLooping = function () {
        this.loopingItems = false;
    };
    BlueprintsManager.prototype.createInitialBlueprint = function (params) {
        this.currentState.totalItemsCount =
            params.totalItemsCount ||
                (this.api.getTotalItemsCount && this.api.getTotalItemsCount()) ||
                this.currentState.totalItemsCount;
        this.currentState.isUsingCustomInfoElements =
            params.isUsingCustomInfoElements ||
                (this.api.isUsingCustomInfoElements &&
                    this.api.isUsingCustomInfoElements()) ||
                this.currentState.isUsingCustomInfoElements;
        params = this.duplicateItemsForSlideshowLoopIfNeeded(params);
        var _a = blueprints.createBlueprint({
            params: params,
            lastParams: this.currentState,
            existingBlueprint: this.existingBlueprint,
            blueprintManagerId: this.id,
            isUsingCustomInfoElements: this.currentState.isUsingCustomInfoElements,
        }), blueprint = _a.blueprint, changedParams = _a.changedParams, reasons = _a.reasons;
        var blueprintChanged = Object.values(changedParams).some(function (changedParam) { return !!changedParam; });
        var blueprintCreated = Object.keys(blueprint).length > 0;
        this.updateLastParamsIfNeeded(params, changedParams, blueprintCreated);
        blueprintCreated &&
            this.api.onBlueprintReady &&
            this.api.onBlueprintReady({
                blueprint: blueprint,
                blueprintChanged: blueprintChanged,
                reasons: reasons,
                initialBlueprint: true,
            });
        return (blueprintCreated &&
            (this.cache[params] = this.existingBlueprint = blueprint));
    };
    BlueprintsManager.prototype.createSingleBlueprint = function (params) {
        if (params === void 0) { params = {}; }
        var isUsingCustomInfoElements = params.isUsingCustomInfoElements;
        var blueprint = blueprints.createBlueprint({
            params: params,
            lastParams: {},
            existingBlueprint: {},
            blueprintManagerId: this.id + '_singleBlueprint',
            isUsingCustomInfoElements: isUsingCustomInfoElements,
        }).blueprint;
        return blueprint;
    };
    BlueprintsManager.prototype.duplicateGalleryItems = function (_a) {
        var items = _a.items, _b = _a.duplicateFactor, duplicateFactor = _b === void 0 ? 1 : _b;
        items = items || this.currentState.items;
        var uniqueItems = items.slice(0, this.currentState.totalItemsCount);
        for (var i = 0; i < duplicateFactor; i++) {
            items = items.concat.apply(items, uniqueItems);
        }
        this.loopingItems = true;
        return items;
    };
    // Wrapper for the duplicateGalleryItems func, it duplicates, and createBlueprint with duplicated items *
    BlueprintsManager.prototype.duplicateItemsAndCreateBlueprint = function () {
        var items = this.duplicateGalleryItems({});
        this.createBlueprint({ items: items });
    };
    // The following function duplicate the items if necessary for slideshowLoop
    BlueprintsManager.prototype.duplicateItemsForSlideshowLoopIfNeeded = function (params) {
        var items = params.items, options = params.options;
        var slideshowLoop = options.slideshowLoop, scrollDirection = options.scrollDirection;
        var totalItemsCount = this.currentState.totalItemsCount;
        var loopThreshold = 30;
        // If we've reached last items (no more items in server), and there are less items than the threshold
        var numOfItemsCondition = items.length < loopThreshold && items.length === totalItemsCount;
        // If the gallery is a horizontal scrolling gallery
        var isHorizontalScrolling = scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL;
        // If slideshowLoop is True and both conditions are True as well then we duplicate number of items to reach threshold
        if (slideshowLoop && numOfItemsCondition && isHorizontalScrolling) {
            var duplicateFactor = Math.ceil(loopThreshold / items.length) - 1;
            return __assign(__assign({}, params), { items: this.duplicateGalleryItems({ items: items, duplicateFactor: duplicateFactor }) });
        }
        return params;
    };
    // ------------------ Get all the needed raw data ---------------------------- //
    BlueprintsManager.prototype.completeParams = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, container, items, options, id;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = params || {}, container = _a.container, items = _a.items, options = _a.options, id = _a.id;
                        return [4 /*yield*/, this.fetchContainerIfNeeded(container)];
                    case 1:
                        container = _b.sent();
                        return [4 /*yield*/, this.fetchItemsIfNeeded(items)];
                    case 2:
                        items = _b.sent();
                        return [4 /*yield*/, this.fetchOptionsIfNeeded(options)];
                    case 3:
                        options = _b.sent(); // can be async... TODO
                        return [2 /*return*/, { container: container, items: items, options: options, id: id }];
                }
            });
        });
    };
    BlueprintsManager.prototype.fetchContainerIfNeeded = function (container) {
        return __awaiter(this, void 0, void 0, function () {
            var shouldFetchContainer, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        shouldFetchContainer = function (_container) {
                            var should = true;
                            if (_container && Object.keys(_container).length > 0) {
                                should = false;
                            }
                            return should;
                        };
                        if (!shouldFetchContainer(container)) return [3 /*break*/, 3];
                        _a = this.api.fetchContainer;
                        if (!_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.api.fetchContainer()];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        // dimensions = {yonatanFakeDimensions: true, width: "", height: ""} // TODO - is there something here???
                        container =
                            (_a) ||
                                this.currentState.container;
                        _b.label = 3;
                    case 3: return [2 /*return*/, container];
                }
            });
        });
    };
    BlueprintsManager.prototype.fetchItemsIfNeeded = function (items) {
        return __awaiter(this, void 0, void 0, function () {
            var shouldFetchItems, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        shouldFetchItems = function (_items) {
                            var should = true;
                            if (_items && _items.length > 0) {
                                should = false;
                            }
                            return should;
                        };
                        if (!shouldFetchItems(items)) return [3 /*break*/, 3];
                        _a = !this.loopingItems &&
                            this.api.fetchItems;
                        if (!_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.api.fetchItems()];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        // items = ['yonatan - fake items'] // getGalleryDataFromServer(); - worker code to be used here.
                        items =
                            (_a) ||
                                this.currentState.items;
                        _b.label = 3;
                    case 3: 
                    // TODO - this.loadItemsDimensionsIfNeeded();
                    return [2 /*return*/, items];
                }
            });
        });
    };
    BlueprintsManager.prototype.fetchOptionsIfNeeded = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var shouldFetchOptions, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        shouldFetchOptions = function (_options) {
                            var should = true;
                            if (_options && Object.keys(_options).length > 0) {
                                // TODO - should check if they are ready options and use ClientLib if not?
                                should = false;
                            }
                            return should;
                        };
                        if (!shouldFetchOptions(options)) return [3 /*break*/, 3];
                        _a = this.api.fetchOptions;
                        if (!_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.api.fetchOptions()];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        // styles = ['yonatan - fake styles'] // get styles - from SA ; - worker code to be used here.
                        options =
                            (_a) ||
                                this.currentState.options;
                        _b.label = 3;
                    case 3: return [2 /*return*/, options];
                }
            });
        });
    };
    BlueprintsManager.prototype.updateLastParamsIfNeeded = function (_a, changedParams, blueprintCreated) {
        var items = _a.items, container = _a.container, options = _a.options;
        if (blueprintCreated) {
            this.currentState.items = changedParams.itemsChanged
                ? items
                : this.currentState.items;
            this.currentState.container = changedParams.containerChanged
                ? __assign({}, container) : this.currentState.container;
            this.currentState.options = changedParams.optionsChanged
                ? __assign({}, options) : this.currentState.options;
        }
    };
    BlueprintsManager.prototype.needMoreItems = function (currentItemLength) {
        this.getMoreItems(currentItemLength);
    };
    return BlueprintsManager;
}());
export default BlueprintsManager;
/* eslint-enable prettier/prettier */
//# sourceMappingURL=BlueprintsManager.js.map