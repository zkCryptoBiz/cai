import { __spreadArray } from "tslib";
import { Layouter, ItemsHelper } from 'pro-layouts';
import { populateWithDefaultOptions, addPresetOptions, dimensionsHelper, processLayouts, GALLERY_CONSTS, extendNestedOptionsToIncludeOldAndNew, } from 'pro-gallery-lib';
var Blueprints = /** @class */ (function () {
    function Blueprints() {
    }
    Blueprints.prototype.createBlueprint = function (_a) {
        // cacheBlocker
        // if (this.cache[params]) return this.cache[params];
        var params = _a.params, lastParams = _a.lastParams, existingBlueprint = _a.existingBlueprint, blueprintManagerId = _a.blueprintManagerId, isUsingCustomInfoElements = _a.isUsingCustomInfoElements;
        this.reasons = {
            items: '',
            itemsAdded: '',
            options: '',
            container: '',
        };
        var changedParams = {};
        try {
            var newContainerParams = params.container, newItemsParams = params.items, newOptions = params.options;
            var oldContainerParams = lastParams.container, oldItemsParams = lastParams.items, oldOptions = lastParams.options;
            // getItems,options and dimesions if not supplied in params;
            var _b = this.formatItemsIfNeeded(newItemsParams, oldItemsParams), formattedItems = _b.formattedItems, itemsChanged = _b.changed;
            var _c = this.formatOptionsIfNeeded(newOptions, oldOptions, isUsingCustomInfoElements), formattedOptions = _c.formattedOptions, optionsChanged = _c.changed;
            var _d = this.formatContainerIfNeeded(newContainerParams, oldContainerParams, oldOptions, formattedOptions || existingBlueprint.options, optionsChanged), formattedContainer = _d.formattedContainer, containerChanged = _d.changed;
            var changed = itemsChanged || optionsChanged || containerChanged;
            changedParams = { itemsChanged: itemsChanged, optionsChanged: optionsChanged, containerChanged: containerChanged };
            if (changed || !existingBlueprint) {
                if (!existingBlueprint) {
                    existingBlueprint = {};
                }
                var structure = this.createStructure({
                    formattedContainer: formattedContainer || existingBlueprint.container,
                    formattedItems: formattedItems || existingBlueprint.items,
                    formattedOptions: formattedOptions || existingBlueprint.options,
                }, changed);
                // assign changed values w/o replacing the original object;
                if (formattedOptions) {
                    existingBlueprint.options = formattedOptions;
                }
                if (formattedItems) {
                    existingBlueprint.items = formattedItems;
                }
                if (formattedContainer) {
                    existingBlueprint.container = formattedContainer;
                }
                existingBlueprint.structure = structure;
                // if its an infinite gallery - let the container loose
                var isInfinite = existingBlueprint.options.scrollDirection ===
                    GALLERY_CONSTS.scrollDirection.VERTICAL &&
                    existingBlueprint.options.enableInfiniteScroll;
                if (isInfinite) {
                    existingBlueprint.container.height =
                        existingBlueprint.container.galleryHeight = structure.height;
                }
            }
        }
        catch (error) {
            console.error('Could not create blueprint, error:', error);
        }
        var reasons = Object.entries(this.reasons)
            .reduce(function (reasons, _a) {
            var param = _a[0], reason = _a[1];
            return __spreadArray(__spreadArray([], reasons, true), ["".concat(param, ": ").concat(reason)], false);
        }, [])
            .join(', ');
        // return the existing or the modified existing object
        return {
            blueprint: existingBlueprint,
            changedParams: changedParams,
            blueprintManagerId: blueprintManagerId,
            reasons: reasons,
        };
    };
    // ------------------ Raw data to Formated data (if needed) ---------------------------- //
    Blueprints.prototype.formatItemsIfNeeded = function (items, lastItems) {
        var _this = this;
        var itemsWereAdded = function (newItemsParams, oldItemsParams) {
            if (newItemsParams === oldItemsParams) {
                _this.reasons.itemsAdded = 'items are the same object.';
                return false; // it is the exact same object
            }
            if (!newItemsParams) {
                _this.reasons.itemsAdded = 'new items do not exist.';
                return false; // new items do not exist (use old items)
            }
            if (!oldItemsParams || (oldItemsParams && oldItemsParams.length === 0)) {
                _this.reasons.itemsAdded = 'old items do not exist.';
                return false; // old items do not exist (it is not items addition)
            }
            if (oldItemsParams.length >= newItemsParams.length) {
                _this.reasons.itemsAdded = 'more old items than new items.';
                return false; // more old items than new items
            }
            var idsNotChanged = oldItemsParams.reduce(function (is, _item, idx) {
                // check that all the existing items exist in the new array
                return is && _item.id === newItemsParams[idx].itemId;
            }, true);
            if (!idsNotChanged) {
                _this.reasons.itemsAdded = 'items ids were changed. ';
            }
            return idsNotChanged;
        };
        var itemsHaveChanged = function (newItemsParams, oldItemsParams) {
            if (newItemsParams === oldItemsParams) {
                _this.reasons.items = 'items are the same object.';
                return false; // it is the exact same object
            }
            if (!newItemsParams) {
                _this.reasons.items = 'new items do not exist.';
                return false; // new items do not exist (use old items)
            }
            if (!oldItemsParams || (oldItemsParams && oldItemsParams.length === 0)) {
                _this.reasons.items = 'old items do not exist.';
                return true; // old items do not exist
            }
            if (oldItemsParams.length !== newItemsParams.length) {
                _this.reasons.items = 'more new items than old items (or vice versa).';
                return true; // more new items than old items (or vice versa)
            }
            return newItemsParams.some(function (newItem, idx) {
                // check that all the items are identical
                var existingItem = oldItemsParams[idx];
                try {
                    var itemsChanged = !newItem ||
                        !existingItem ||
                        newItem.itemId !== existingItem.itemId ||
                        newItem.mediaUrl !== existingItem.mediaUrl ||
                        newItem.measured !== existingItem.measured ||
                        (newItem.metaData &&
                            existingItem.metaData &&
                            (newItem.metaData.type !== existingItem.metaData.type ||
                                newItem.metaData.title !== existingItem.metaData.title ||
                                newItem.metaData.description !==
                                    existingItem.metaData.description ||
                                newItem.metaData.width !== existingItem.metaData.width ||
                                newItem.metaData.height !== existingItem.metaData.height)) ||
                        (newItem.metaData &&
                            newItem.metaData.type === 'text' &&
                            existingItem.metaData &&
                            existingItem.metaData.type === 'text' &&
                            (newItem.metaData.html !== existingItem.metaData.html ||
                                newItem.metaData.textStyle !==
                                    existingItem.metaData.textStyle ||
                                newItem.metaData.editorHtml !==
                                    existingItem.metaData.editorHtml));
                    if (itemsChanged) {
                        _this.reasons.items = "items #".concat(idx, " id was changed.");
                    }
                    return itemsChanged;
                }
                catch (e) {
                    _this.reasons.items = 'an error occured';
                    return true;
                }
            }, false);
        };
        var oldItemsParams = lastItems;
        var changed = false;
        var formattedItems;
        if (itemsWereAdded(items, oldItemsParams)) {
            formattedItems = oldItemsParams.concat(items.slice(oldItemsParams.length).map(function (item) {
                return ItemsHelper.convertDtoToLayoutItem(item);
            }));
            this.gettingMoreItems = false; // probably finished getting more items       //TODO - what is this and how we keep it alive if needed?
            changed = true;
        }
        else if (itemsHaveChanged(items, oldItemsParams)) {
            formattedItems = items.map(function (item) {
                return Object.assign(ItemsHelper.convertDtoToLayoutItem(item));
            });
            this.gettingMoreItems = false; // probably finished getting more items
            changed = true;
        }
        return { formattedItems: formattedItems, changed: changed };
    };
    Blueprints.prototype.formatOptionsIfNeeded = function (options, lastOptions, isUsingCustomInfoElements) {
        var _this = this;
        var optionsHaveChanged = function (newOptions, oldOptions) {
            if (!newOptions) {
                _this.reasons.options = 'no new options.';
                return false; // no new options - use old options
            }
            if (!oldOptions) {
                _this.reasons.options = 'no old options.';
                return true; // no old options
            }
            try {
                var oldOptionsSorted_1 = {};
                Object.keys(oldOptions)
                    .sort() // sort by keys alphabetically
                    .forEach(function (key) { return (oldOptionsSorted_1[key] = oldOptions[key]); });
                var newOptionsSorted_1 = {};
                Object.keys(newOptions)
                    .sort() // sort by keys alphabetically
                    .forEach(function (key) { return (newOptionsSorted_1[key] = newOptions[key]); });
                var wasChanged = JSON.stringify(newOptionsSorted_1) !== JSON.stringify(oldOptionsSorted_1);
                if (wasChanged) {
                    _this.reasons.options = 'options were changed.';
                }
                return wasChanged;
            }
            catch (e) {
                console.error('Could not compare options', e);
                return false;
            }
        };
        var oldOptions = lastOptions;
        var changed = false;
        var formattedOptions;
        if (optionsHaveChanged(options, oldOptions)) {
            var mergedOldAndNewStyles = extendNestedOptionsToIncludeOldAndNew(options); //add both old and new options
            var fullOptionsOverDefualts = populateWithDefaultOptions(mergedOldAndNewStyles); //add default for any undefined option
            formattedOptions = extendNestedOptionsToIncludeOldAndNew(processLayouts(addPresetOptions(fullOptionsOverDefualts), isUsingCustomInfoElements)); // TODO make sure the processLayouts is up to date. delete addLayoutStyles from layoutsHelper when done with it...
            changed = true;
        }
        return { formattedOptions: formattedOptions, changed: changed };
    };
    Blueprints.prototype.formatContainerIfNeeded = function (container, lastContainer, lastOptions, formattedOptions, optionsChanged) {
        var _this = this;
        var containerHasChanged = function (_a) {
            var newContainerParams = _a.newContainerParams, oldContainerParams = _a.oldContainerParams, oldOptions = _a.oldOptions;
            if (!oldOptions || !oldContainerParams) {
                _this.reasons.container = 'no old container or options. ';
                return true; // no old container or options (style may change container)
            }
            if (!newContainerParams) {
                _this.reasons.container = 'no new container.';
                return false; // no new continainer
            }
            var containerHasChanged = {
                height: formattedOptions.scrollDirection ===
                    GALLERY_CONSTS.scrollDirection.VERTICAL &&
                    formattedOptions.enableInfiniteScroll // height doesnt matter if the new gallery is going to be vertical
                    ? false
                    : !!newContainerParams.height &&
                        newContainerParams.height !== oldContainerParams.height,
                width: !oldContainerParams ||
                    (!!newContainerParams.width &&
                        newContainerParams.width !== oldContainerParams.width),
                scrollBase: newContainerParams.scrollBase !== oldContainerParams.scrollBase,
            };
            return Object.keys(containerHasChanged).reduce(function (is, key) {
                if (containerHasChanged[key]) {
                    _this.reasons.container += "container.".concat(key, " has changed. ");
                }
                return is || containerHasChanged[key];
            }, false);
        };
        var oldContainerParams = lastContainer;
        var changed = false;
        var oldOptions = lastOptions;
        var formattedContainer;
        if (optionsChanged || // If options changed they could affect the container and a new container must be created (slideshow,thumbs,shadow,borders...etc)
            containerHasChanged({
                newContainerParams: container,
                oldContainerParams: oldContainerParams,
                oldOptions: oldOptions,
            })) {
            dimensionsHelper.updateParams({
                options: formattedOptions,
                container: container,
            });
            changed = true;
            formattedContainer = Object.assign({}, container, dimensionsHelper.getGalleryDimensions());
        }
        return { formattedContainer: formattedContainer, changed: changed };
    };
    Blueprints.prototype.createStructure = function (_a) {
        var formattedContainer = _a.formattedContainer, formattedOptions = _a.formattedOptions, formattedItems = _a.formattedItems;
        var layoutParams = {
            items: formattedItems,
            container: formattedContainer,
            styleParams: formattedOptions,
            options: {
                showAllItems: true,
                skipVisibilitiesCalc: true,
                useLayoutStore: false,
            },
        };
        // if (this.layouter && addingItems) {
        //   layoutParams.options.useExistingLayout = true;
        // } else {
        layoutParams.options.createLayoutOnInit = false; // TODO - what does this do?
        this.layouter = new Layouter(layoutParams); // TODO - no need for "this."
        // }
        return this.layouter.createLayout(layoutParams);
    };
    return Blueprints;
}());
var blueprints = new Blueprints();
export default blueprints;
//# sourceMappingURL=Blueprints.js.map