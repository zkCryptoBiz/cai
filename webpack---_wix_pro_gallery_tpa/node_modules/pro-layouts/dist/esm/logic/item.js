import { __assign } from "tslib";
import { utils } from './utils';
var Item = /** @class */ (function () {
    /* @ngInject */
    function Item(config) {
        this.style = {};
        this.visibility = {};
        config = config || {};
        if (!config.dto) {
            console.error('Item has no DTO', config);
            config.dto = {};
        }
        this.config = config;
        this.dto = config.dto;
        this.idx = config.idx;
        this.inGroupIdx = config.inGroupIdx;
        this.container = config.container;
        this.cubeType = 'fill';
        if (config.styleParams) {
            var styleParams = config.styleParams;
            this.cubeType = styleParams.cubeType;
            this.cubeImages = styleParams.cubeImages;
            this._cropRatio = styleParams.layoutParams.cropRatio;
            this.rotatingCropRatios = styleParams.rotatingCropRatios;
            this.smartCrop = styleParams.smartCrop;
            this.cropOnlyFill = styleParams.cropOnlyFill;
            this.imageMargin = styleParams.imageMargin;
            this.gallerySpacing = styleParams.layoutParams.gallerySpacing;
            this.scatter = styleParams.scatter;
            this.rotatingScatter = styleParams.rotatingScatter;
            this.smartCrop = styleParams.smartCrop;
            this.useMaxDimensions =
                styleParams.useMaxDimensions && this.itemType !== 'text';
            this.cubeFitPosition = styleParams.cubeFitPosition;
        }
        this._groupOffset = {
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
        };
        this._group = {};
        this.calcPinOffset = function () { return 0; };
        this.resize(1);
    }
    Item.prototype.fixMetadataVerticalVideoRatio = function (metadata) {
        if (metadata.qualities && metadata.qualities[0]) {
            //fix incorrect width height for vertical videos
            var qualities = metadata.qualities;
            var _a = qualities[qualities.length - 1], height = _a.height, width = _a.width;
            metadata.height = height;
            metadata.width = width;
        }
    };
    Item.prototype.resize = function (scaleOrDimensions) {
        var scale = 1;
        if (scaleOrDimensions === false) {
            return;
        }
        else if (scaleOrDimensions > 0) {
            scale = scaleOrDimensions;
        }
        else if (typeof scaleOrDimensions === 'object') {
            if (scaleOrDimensions.width) {
                var w = Math.max(1, scaleOrDimensions.width);
                scale = w / this.width;
            }
            else if (scaleOrDimensions.height) {
                var h = Math.max(1, scaleOrDimensions.height);
                scale = h / this.height;
            }
        }
        this.width *= scale;
        this.height *= scale;
        this.resized = true;
        return this;
    };
    Item.prototype.pinToCorner = function (cornerName, pinAfter) {
        var _this = this;
        if (pinAfter === void 0) { pinAfter = false; }
        var isTop = cornerName.indexOf('top') >= 0;
        var isLeft = cornerName.indexOf('left') >= 0;
        this.style.top = isTop ? 0 : 'auto';
        this.style.bottom = isTop ? 'auto' : 0;
        this.style.left = isLeft ? 0 : 'auto';
        this.style.right = isLeft ? 'auto' : 0;
        this.pin = cornerName;
        this.isPinnedTop = isTop;
        this.isPinnedLeft = isLeft;
        this.pinAfter = pinAfter;
        this.pinAfterType = isTop ? 'top' : isLeft ? 'left' : '';
        this.calcPinOffset = function (groupSize, dir) {
            if (!_this.pinAfter) {
                return 0;
            }
            else if (_this.pin === dir) {
                //this is used only for 3h/3v group types - to calc the offset of the middle item
                var m = _this.imageMargin / 2;
                // return ((groupSize - 6 * m) * this.pinOffset + 2 * m);
                if (dir === 'top') {
                    return _this.pinAfter.height + 2 * m;
                }
                else if (dir === 'left') {
                    return _this.pinAfter.width + 2 * m;
                }
                else {
                    return 0;
                }
                // return ((groupSize - 6 * m) * this.pinOffset + 4 * m);
            }
            else {
                return 0;
            }
        };
    };
    Item.prototype.setPosition = function (position) {
        this.style.position = position;
    };
    Item.prototype.getPosition = function (pos) {
        return parseInt(pos, 10) >= 0 ? pos : 'auto';
    };
    Item.prototype.calcScatter = function (offset) {
        var m = this.imageMargin / 2;
        var g = this.gallerySpacing;
        var spaceLeft = offset.left > 0 ? m : g;
        var spaceRight = this.container.galleryWidth - offset.right > 2 * m ? m : g;
        var spaceUp = offset.top > 0 ? m : g;
        var spaceDown = this.container.galleryHeight - offset.bottom > 2 * m ? m : g;
        if (this.rotatingScatter.length > 0) {
            try {
                var scatterArr = this.rotatingScatter.split(',');
                var _a = scatterArr[this.idx % scatterArr.length]
                    .split('/')
                    .map(function (dim) { return parseInt(dim); })
                    .map(function (dim) { return dim / 100; }), x = _a[0], y = _a[1];
                var horizontalShift = x * (x > 0 ? spaceRight : spaceLeft);
                var verticalShift = y * (y > 0 ? spaceDown : spaceUp);
                return { x: horizontalShift, y: verticalShift };
            }
            catch (e) {
                console.error('Cannot calculate rotating scatter', e);
            }
        }
        else if (this.scatter > 0) {
            var minShift = 0.4 * (this.scatter / 100);
            var horizontalShift = utils.hashToRandomInt(this.seed + offset.right + 'x', -spaceLeft, spaceRight);
            horizontalShift *= this.scatter / 100;
            horizontalShift *= 1 - minShift;
            horizontalShift +=
                (horizontalShift > 0 ? minShift * spaceRight : minShift * spaceLeft) *
                    Math.sign(horizontalShift);
            horizontalShift = Math.round(horizontalShift);
            var verticalShift = utils.hashToRandomInt(this.seed + offset.right + 'y', -spaceUp, spaceDown);
            verticalShift *= this.scatter / 100;
            verticalShift *= 1 - minShift;
            verticalShift +=
                (verticalShift > 0 ? minShift * spaceDown : minShift * spaceUp) *
                    Math.sign(verticalShift);
            verticalShift = Math.round(verticalShift);
            return { x: horizontalShift, y: verticalShift };
        }
        else {
            return { x: 0, y: 0 };
        }
    };
    Object.defineProperty(Item.prototype, "top", {
        get: function () {
            return this.getPosition(this.style.top);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "left", {
        get: function () {
            return this.getPosition(this.style.left);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "right", {
        get: function () {
            return this.getPosition(this.style.right);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "bottom", {
        get: function () {
            return this.getPosition(this.style.bottom);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "group", {
        get: function () {
            return this._group;
        },
        set: function (group) {
            Object.assign(this._group, group);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "groupOffset", {
        set: function (offset) {
            Object.assign(this._groupOffset, offset);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "offset", {
        get: function () {
            var _a;
            var offset = {
                top: this._groupOffset.top +
                    (this.isPinnedTop
                        ? this.calcPinOffset(this._group.height, 'top')
                        : this._group.height - this.outerHeight) || 0,
                left: this._groupOffset.left +
                    (this.isPinnedLeft
                        ? this.calcPinOffset(this._group.width, 'left')
                        : this._group.width - this.outerWidth) || 0,
            };
            var _b = this.dimensions, _c = _b.fixTop, fixTop = _c === void 0 ? 0 : _c, _d = _b.fixLeft, fixLeft = _d === void 0 ? 0 : _d, _e = _b.fixRight, fixRight = _e === void 0 ? 0 : _e, _f = _b.fixBottom, fixBottom = _f === void 0 ? 0 : _f;
            offset.innerTop = fixTop;
            offset.innerLeft = fixLeft;
            offset.innerRight = fixRight;
            offset.innerBottom = fixBottom;
            offset.right = offset.left + this.width;
            offset.bottom = offset.top + this.height;
            if (this.scatter > 0 || ((_a = this.rotatingScatter) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                var _g = this.calcScatter(offset), x = _g.x, y = _g.y;
                offset.left += x;
                offset.top += y;
                offset.right = offset.left + this.width;
                offset.bottom = offset.top + this.height;
            }
            return offset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "id", {
        get: function () {
            return this.dto.id || this.dto.photoId || this.dto.itemId;
        },
        set: function (id) {
            this.dto.itemId = this.dto.photoId = this.dto.id = id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "hash", {
        get: function () {
            return this.dto.hash || this.dto.mediaUrl || this.dto.id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "seed", {
        get: function () {
            return this.dto.seed || utils.hashToInt(this.hash);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "metadata", {
        get: function () {
            return this.dto.metadata || this.dto.metaData || {};
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "itemType", {
        get: function () {
            return this.metadata.type || 'image';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "maxWidth", {
        get: function () {
            return this.dto.width || this.dto.w;
        },
        set: function (w) {
            this.dto.width = w;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "outerWidth", {
        get: function () {
            return this.width + 2 * this.margins;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "infoWidth", {
        get: function () {
            return this.Group ? this.Group.infoWidth : 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "orgWidth", {
        get: function () {
            return this.style.orgWidth || this.dto.width || this.dto.w || 1; //make sure the width / height is not undefined (crashes the gallery)
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "width", {
        get: function () {
            var width;
            if (this.cubeImages && this.ratio >= this.cropRatio) {
                width = this.style.cubedWidth || this.orgHeight * this.cropRatio;
            }
            else {
                width = this.orgWidth;
            }
            return Math.max(width, 1);
        },
        set: function (w) {
            // prettier-ignore
            this.style.cubedWidth =
                // prettier-ignore
                this.style.orgWidth =
                    // prettier-ignore
                    this.style.width =
                        // prettier-ignore
                        Math.max(1, w);
            var _a = this.dimensions, _b = _a.fixLeft, fixLeft = _b === void 0 ? 0 : _b, _c = _a.fixRight, fixRight = _c === void 0 ? 0 : _c;
            this.style.innerWidth = this.style.width - fixLeft - fixRight;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "outerHeight", {
        get: function () {
            return this.height + 2 * this.margins;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "orgHeight", {
        get: function () {
            return this.style.orgHeight || this.dto.height || this.dto.h || 1; //make sure the width / height is not undefined (creashes the gallery)
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "height", {
        get: function () {
            var height;
            if (this.cubeImages && this.ratio < this.cropRatio) {
                height = this.style.cubedHeight || this.orgWidth / this.cropRatio;
            }
            else {
                height = this.orgHeight;
            }
            return Math.max(height, 1);
        },
        set: function (h) {
            // prettier-ignore
            this.style.cubedHeight =
                // prettier-ignore
                this.style.orgHeight =
                    // prettier-ignore
                    this.style.height =
                        // prettier-ignore
                        Math.max(1, h);
            var _a = this.dimensions, _b = _a.fixTop, fixTop = _b === void 0 ? 0 : _b, _c = _a.fixBottom, fixBottom = _c === void 0 ? 0 : _c;
            this.style.innerHeight = this.style.height - fixBottom - fixTop;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "maxHeight", {
        get: function () {
            return this.dto.height || this.dto.h;
        },
        set: function (h) {
            h = this.dto.height;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "infoHeight", {
        get: function () {
            return this.Group ? this.Group.infoHeight : 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "margins", {
        get: function () {
            return this.imageMargin / 2 || 0;
        },
        set: function (m) {
            this.imageMargin = m;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "dimensions", {
        get: function () {
            var _this = this;
            var isGridFit = this.cubeImages && this.cubeType === 'fit';
            var targetWidth = this.width;
            var targetHeight = this.height;
            var setTargetDimensions = function (setByWidth, ratio) {
                if (setByWidth) {
                    targetWidth = _this.useMaxDimensions
                        ? Math.min(_this.width, _this.maxWidth)
                        : _this.width;
                    targetHeight = targetWidth / ratio;
                }
                else {
                    targetHeight = _this.useMaxDimensions
                        ? Math.min(_this.height, _this.maxHeight)
                        : _this.height;
                    targetWidth = targetHeight * ratio;
                }
            };
            var isLandscape = this.ratio >= this.cropRatio; //relative to container size
            if (isGridFit) {
                setTargetDimensions(isLandscape, this.ratio);
            }
            else if (this.useMaxDimensions &&
                (this.width > this.maxWidth || this.height > this.maxHeight)) {
                if (this.cubeImages) {
                    setTargetDimensions(!isLandscape, this.cropRatio);
                }
                else {
                    setTargetDimensions(!isLandscape, this.ratio);
                }
            }
            var fixVals = {
                fixTop: (this.height - targetHeight) / 2,
                fixLeft: (this.width - targetWidth) / 2,
                fixRight: (this.width - targetWidth) / 2,
                fixBottom: (this.height - targetHeight) / 2,
            };
            switch (this.cubeFitPosition) {
                case 'TOP':
                    fixVals.fixTop = 0;
                    fixVals.fixBottom *= 2;
                    break;
                case 'BOTTOM':
                    fixVals.fixTop *= 2;
                    fixVals.fixBottom = 0;
                    break;
                case 'LEFT':
                    fixVals.fixLeft = 0;
                    fixVals.fixRight *= 2;
                    break;
                case 'RIGHT':
                    fixVals.fixLeft *= 2;
                    fixVals.fixRight = 0;
                    break;
            }
            return fixVals;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "cropRatio", {
        get: function () {
            var _this = this;
            var ratio;
            if (this.rotatingCropRatio) {
                ratio = this.rotatingCropRatio;
            }
            else if (this.rotatingCropRatios && this.rotatingCropRatios.length > 0) {
                var cropRatiosArr = String(this.rotatingCropRatios).split(',');
                ratio = this.rotatingCropRatio =
                    cropRatiosArr[this.idx % cropRatiosArr.length];
            }
            if (!ratio && typeof this._cropRatio === 'function') {
                ratio = this._cropRatio();
            }
            if (!ratio && this.cropOnlyFill && this.cubeType === 'fit') {
                ratio = this.ratio;
            }
            if (!ratio) {
                ratio = this._cropRatio || this.ratio;
            }
            if (this.dynamicCropRatios !== null && typeof ratio === 'string') {
                if (!this.dynamicCropRatios) {
                    var dynamicCropRegex = /^\d*\.?\d*(%|px)\/\d*\.?\d*(%|px)$/;
                    var match = dynamicCropRegex.exec(ratio);
                    if (match) {
                        this.dynamicCropRatios = ratio.split('/').map(function (val, idx) {
                            if (val.indexOf('%') > 0) {
                                return {
                                    type: '%',
                                    val: parseFloat(val.replace('%', '')) / 100,
                                    dim: idx === 0 ? 'galleryWidth' : 'galleryHeight',
                                };
                            }
                            else {
                                return {
                                    type: 'px',
                                    val: parseInt(val.replace('px', '')),
                                };
                            }
                        });
                    }
                    else {
                        this.dynamicCropRatios = null;
                    }
                }
                if (this.dynamicCropRatios) {
                    var dynamicCropRatio = this.dynamicCropRatios.map(function (r) {
                        if (r.type === '%') {
                            var dim = _this.container[r.dim] +
                                (r.dim === 'galleryHeight' ? _this.imageMargin / 2 : 0);
                            var relativeDim = r.val * dim - _this.imageMargin;
                            return relativeDim;
                        }
                        else {
                            return r.val;
                        }
                    });
                    ratio = dynamicCropRatio[0] / dynamicCropRatio[1];
                }
            }
            ratio = Number(ratio);
            if (this.smartCrop === true) {
                if (this.isPortrait) {
                    ratio = Math.min(ratio, 1 / ratio);
                }
                else {
                    ratio = Math.max(ratio, 1 / ratio);
                }
            }
            if (this.cubeType === 'min') {
                ratio = Math.max(ratio, this.orgRatio);
            }
            else if (this.cubeType === 'max') {
                ratio = Math.min(ratio, this.orgRatio);
            }
            return ratio;
        },
        set: function (ratio) {
            if (typeof this._cropRatio === 'number') {
                this._cropRatio = ratio;
                this.style.cubedHeight = this.style.cubedWidth = 0;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "orientation", {
        get: function () {
            return this.ratio < 0.999 ? 'portrait' : 'landscape'; //make sure that almost square images get the same treatment
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "isPortrait", {
        get: function () {
            return this.orientation === 'portrait';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "isLandscape", {
        get: function () {
            return this.orientation === 'landscape';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "ratio", {
        get: function () {
            if (!this.orgRatio) {
                this.orgRatio = this.orgWidth / this.orgHeight;
            }
            return this.orgRatio;
        },
        set: function (r) {
            this.orgRatio = r;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "roundedStyle", {
        get: function () {
            return __assign(__assign({}, this.style), { width: Math.round(this.style.width), height: Math.round(this.style.height) });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "scheme", {
        get: function () {
            return {
                id: this.id,
                idx: this.idx,
                inGroupIdx: this.inGroupIdx,
                dto: this.dto,
                type: this.type,
                style: this.style,
                roundedStyle: this.roundedStyle,
                width: this.width,
                maxWidth: this.maxWidth,
                outerWidth: this.outerWidth,
                infoWidth: this.infoWidth,
                margins: this.margins,
                ratio: this.ratio,
                dimensions: this.dimensions,
                cropRatio: this.cropRatio,
                isCropped: this.cubeImages,
                cropType: this.cubeType,
                height: this.height,
                maxHeight: this.maxHeight,
                outerHeight: this.outerHeight,
                infoHeight: this.infoHeight,
                group: this.group,
                offset: this.offset,
                groupOffset: this._groupOffset,
                orientation: this.orientation,
                isPortrait: this.isPortrait,
                isLandscape: this.isLandscape,
                visibility: this.visibility,
            };
        },
        enumerable: false,
        configurable: true
    });
    return Item;
}());
export { Item };
//# sourceMappingURL=item.js.map