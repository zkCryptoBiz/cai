/* eslint-disable prettier/prettier */
import { utils } from './utils';
import { Item } from './item.js';
import { Group } from './group.js';
import { Strip } from './strip.js';
import { Column } from './column.js';
import layoutsStore from './layoutsStore.js';
var Layouter = /** @class */ (function () {
    function Layouter(layoutParams) {
        //dummy commit
        this.ready = false;
        this.pointer = 0;
        this.layoutItems = [];
        this.findNeighborItem = this.findNeighborItem.bind(this);
        this.updateParams(layoutParams);
        if (this.createLayoutOnInit !== false) {
            this.createLayout(layoutParams);
        }
    }
    Layouter.prototype.updateParams = function (layoutParams) {
        this.srcItems = layoutParams.items;
        this.styleParams = utils.addDefaultStyleParams(layoutParams.styleParams);
        this.container = utils.convertContainer(layoutParams.container, this.styleParams);
        var options = layoutParams.options || {};
        this.useExistingLayout = !!options.useExistingLayout;
        this.createLayoutOnInit = options.createLayoutOnInit;
        this.showAllItems = !!options.showAllItems || !!layoutParams.showAllItems;
        this.useLayoutStore = !!options.useLayoutStore;
    };
    Layouter.prototype.verifyGalleryState = function () {
        if (!this.container.galleryWidth) {
            this.ready = false;
            throw new Error('Layouter: cannot create layout, galleryWidth is undefined or 0');
        }
        if (!this.styleParams.targetItemSize) {
            this.ready = false;
            throw new Error('Layouter: cannot create layout, targetItemSize is undefined or 0');
        }
    };
    Layouter.prototype.calcNumberOfColumns = function (galleryWidth, targetItemSize) {
        var numOfCols = 1;
        if (this.styleParams.isVertical) {
            if (this.styleParams.fixedColumns > 0) {
                numOfCols = this.styleParams.fixedColumns;
            }
            else {
                // find the number of columns that makes each column width the closet to the targetItemSize
                var numOfColsFloat_1 = galleryWidth / targetItemSize;
                var roundFuncs = [Math.floor, Math.ceil];
                var diffs = roundFuncs
                    .map(function (func) { return func(numOfColsFloat_1); }) //round to top, round to bottom
                    .map(function (n) { return Math.round(galleryWidth / n); }) //width of each col
                    .map(function (w) { return Math.abs(targetItemSize - w); }); //diff from targetItemSize
                var roundFunc = roundFuncs[diffs.indexOf(Math.min.apply(Math, diffs))]; //choose the round function that has the lowest diff from the targetItemSize
                numOfCols = roundFunc(numOfColsFloat_1) || 1;
            }
        }
        else {
            numOfCols = 1;
        }
        return numOfCols;
    };
    Layouter.prototype.findShortestColumn = function (columns, groupIdx) {
        var minCol = columns[0];
        if (this.styleParams.placeGroupsLtr) {
            minCol = columns[groupIdx % columns.length];
        }
        else {
            var minColH = -1;
            for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                var column = columns_1[_i];
                var colH = column.height;
                if (colH < minColH || minColH < 0) {
                    minColH = colH;
                    minCol = column;
                }
            }
        }
        return minCol;
    };
    Layouter.prototype.saveExistingLayout = function () {
        if (this.useLayoutStore) {
            layoutsStore.layout = {
                pointer: this.pointer,
                layoutItems: this.layoutItems,
                groups: this.groups,
                strips: this.strips,
                groupIdx: this.groupIdx,
                groupItems: this.groupItems,
                group: this.group,
                strip: this.strip,
                targetItemSize: this.targetItemSize,
                galleryHeight: this.galleryHeight,
                columns: this.columns,
            };
        }
    };
    Layouter.prototype.prepareLayoutParams = function () {
        var _this = this;
        if (this.useExistingLayout && this.pointer > 0) {
            if (this.useLayoutStore) {
                Object.assign(this, layoutsStore.layout);
            }
            else {
                if (this.styleParams.isVertical) {
                    //---------------------| COLUMNS GALLERY |----------------------//
                    //remove items from the last 3 groups;
                    var lastGroups = this.groups.slice(-3);
                    lastGroups.forEach(function (group) {
                        var column = _this.columns[group.columnIdx];
                        if (column) {
                            column.height -= group.totalHeight;
                            column.groups.splice(-1, 1);
                        }
                        _this.groups.splice(-1, 1);
                        group.realItems.forEach(function () {
                            _this.layoutItems.splice(-1, 1);
                            _this.pointer--;
                        });
                        _this.groupIdx--;
                    });
                }
                else {
                    //---------------------| STRIPS GALLERY |----------------------//
                    if (this.scrollDirection === 1) {
                        //remove items from the last group:
                        var lastGroups = this.groups.slice(-1);
                        lastGroups.forEach(function (group) {
                            var column = _this.columns[0];
                            if (column) {
                                column.groups.splice(-1, 1);
                            }
                            var strip = _this.strips[0];
                            if (strip) {
                                strip.setWidth(strip.width - group.width);
                                strip.ratio = strip.width / strip.height;
                                strip.groups.splice(-1, 1);
                                _this.strip = strip;
                            }
                            _this.strips = [];
                            _this.groups.splice(-1, 1);
                            group.realItems.forEach(function () {
                                _this.layoutItems.splice(-1, 1);
                                _this.pointer--;
                            });
                            _this.groupIdx--;
                        });
                        this.galleryHeight = 0;
                    }
                    else {
                        //remove items from the last 2 strips;
                        var lastStrips = this.strips.slice(-2);
                        if (lastStrips) {
                            lastStrips.forEach(function (lastStrip) {
                                if (lastStrip) {
                                    _this.strips.splice(-1, 1);
                                    var groups = lastStrip.groups;
                                    groups.forEach(function (group) {
                                        _this.groups.splice(-1, 1);
                                        group.items.forEach(function () {
                                            _this.layoutItems.splice(-1, 1);
                                            _this.pointer--;
                                        });
                                        _this.groupIdx--;
                                    });
                                }
                            });
                            this.galleryHeight = this.strips.reduce(function (totalHeight, strip) { return (totalHeight += strip.height); }, 0);
                            // this.strip = this.strips[this.strips.length - 1];
                            this.strip = new Strip({
                                idx: this.strips.length + 1,
                                container: this.container,
                                groupsPerStrip: this.styleParams.groupsPerStrip,
                                scrollDirection: this.styleParams.scrollDirection,
                                targetItemSize: this.targetItemSize,
                            });
                        }
                    }
                    this.groupItems = [];
                }
            }
            this.item = {};
            this.pointer = Math.max(0, this.pointer);
            this.maxLoops = this.srcItems.length * 10;
        }
        else {
            this.pointer = 0;
            this.firstGroup = false;
            this.layoutItems = [];
            this.groups = [];
            this.strips = [];
            if (this.styleParams.forceFullHeight) {
                this.targetItemSize = Math.sqrt((this.container.galleryHeight * this.container.galleryWidth) /
                    this.srcItems.length);
            }
            else {
                var gallerySizeVal = void 0;
                if (typeof this.styleParams.targetItemSize === 'function') {
                    gallerySizeVal = this.styleParams.targetItemSize();
                }
                else {
                    gallerySizeVal = this.styleParams.targetItemSize;
                }
                this.targetItemSize =
                    Math.floor(gallerySizeVal) +
                        Math.ceil(2 *
                            (this.styleParams.imageMargin / 2 -
                                this.styleParams.layoutParams.gallerySpacing));
            }
            this.galleryWidth = Math.floor(this.container.galleryWidth);
            this.maxGroupSize = this.getMaxGroupSize();
            this.groupIdx = 0;
            this.item = {};
            this.groupItems = [];
            this.group = {};
            this.bounds = this.container.bounds || {};
            this.strip = new Strip({
                idx: 1,
                container: this.container,
                groupsPerStrip: this.styleParams.groupsPerStrip,
                scrollDirection: this.styleParams.scrollDirection,
                targetItemSize: this.targetItemSize,
            });
            this.galleryHeight = 0;
            this.numOfCols = this.calcNumberOfColumns(this.galleryWidth, this.targetItemSize);
            this.targetItemSize = this.styleParams.isVertical
                ? Math.floor(this.galleryWidth / this.numOfCols)
                : this.targetItemSize;
            var _a = this.styleParams, columnWidths = _a.columnWidths, externalInfoWidth_1 = _a.externalInfoWidth, imageMargin_1 = _a.imageMargin;
            var cropRatio_1 = this.styleParams.layoutParams.cropRatio;
            var columnWidthsArr_1 = false;
            if (columnWidths && columnWidths.length > 0) {
                columnWidthsArr_1 = columnWidths.split(',').map(Number);
                while (columnWidthsArr_1.length < this.numOfCols) {
                    columnWidthsArr_1.push.apply(columnWidthsArr_1, columnWidthsArr_1);
                }
                columnWidthsArr_1 = columnWidthsArr_1.slice(0, this.numOfCols);
                var columnMultiplier_1 = this.galleryWidth / columnWidthsArr_1.reduce(function (a, b) { return a + b; }, 0);
                columnWidthsArr_1 = columnWidthsArr_1.map(function (col) {
                    return Math.round((col *= columnMultiplier_1));
                });
            }
            var totalLeft_1 = 0;
            var remainderWidth_1 = this.galleryWidth;
            var fixedCubeHeight_1;
            this.columns = Array(this.numOfCols)
                .fill(0)
                .map(function (column, idx) {
                //round group widths to fit an even number of pixels
                var colWidth = columnWidthsArr_1
                    ? columnWidthsArr_1[idx]
                    : Math.round(remainderWidth_1 / (_this.numOfCols - idx));
                var curLeft = totalLeft_1;
                totalLeft_1 += colWidth;
                remainderWidth_1 -= colWidth;
                //fix cropRatio of rounded columns
                var infoWidth = Math.round(externalInfoWidth_1 > 1 // integer represent size in pixels, floats size in percentage
                    ? externalInfoWidth_1
                    : externalInfoWidth_1 * colWidth) || 0;
                colWidth -= infoWidth;
                fixedCubeHeight_1 =
                    fixedCubeHeight_1 ||
                        (_this.targetItemSize - infoWidth - imageMargin_1) / cropRatio_1 +
                            imageMargin_1; //calc the cube height only once
                //add space for info on the side
                return new Column(idx, colWidth, curLeft, fixedCubeHeight_1, infoWidth);
            });
            this.maxLoops = this.srcItems.length * 10;
        }
    };
    Layouter.prototype.createLayout = function (layoutParams) {
        if (typeof layoutParams !== 'undefined') {
            this.updateParams(layoutParams);
        }
        this.verifyGalleryState();
        this.prepareLayoutParams();
        while (this.srcItems[this.pointer]) {
            if (this.imagesLeft === 6) {
                this.saveExistingLayout();
            }
            this.maxLoops--;
            if (this.maxLoops <= 0) {
                console.error('Cannot create layout, maxLoops reached!!!');
                return false;
            }
            this.item = new Item({
                idx: this.pointer,
                inGroupIdx: this.groupItems.length + 1,
                scrollTop: this.galleryHeight,
                dto: this.srcItems[this.pointer],
                container: this.container,
                styleParams: this.styleParams,
            });
            this.layoutItems[this.pointer] = this.item;
            //push the image to a group - until its full
            this.groupItems.push(this.item);
            if (this.groupItems.length < this.maxGroupSize &&
                this.srcItems[this.pointer + 1]) {
                this.pointer++;
                continue;
            }
            this.group = new Group({
                idx: this.groupIdx,
                stripIdx: this.strip.idx,
                inStripIdx: this.strip.groups.length + 1,
                top: this.galleryHeight,
                items: this.groupItems,
                isLastItems: this.isLastImages,
                targetItemSize: this.targetItemSize,
                showAllItems: this.showAllItems,
                container: this.container,
                styleParams: this.styleParams,
            });
            this.groups[this.groupIdx] = this.group;
            //take back the pointer in case the group was created with less items
            this.pointer += this.group.realItems.length - this.groupItems.length;
            this.groupIdx++;
            this.groupItems = [];
            //resize and fit the group in the strip / column
            if (!this.styleParams.isVertical) {
                //---------------------| STRIPS GALLERY |----------------------//
                if (this.strip.isFull(this.group, this.isLastImage)) {
                    //close the current strip
                    this.strip.resizeToHeight(this.galleryWidth / this.strip.ratio);
                    this.strip.setWidth(this.galleryWidth);
                    this.galleryHeight += this.strip.height;
                    this.columns[0].addGroups(this.strip.groups);
                    this.strips.push(this.strip);
                    //open a new strip
                    this.strip = new Strip({
                        idx: this.strip.idx + 1,
                        container: this.container,
                        groupsPerStrip: this.styleParams.groupsPerStrip,
                        scrollDirection: this.styleParams.scrollDirection,
                        targetItemSize: this.targetItemSize,
                    });
                    //reset the group (this group will be rebuilt)
                    this.pointer -= this.group.realItems.length - 1;
                    this.groupIdx--;
                    continue;
                }
                //add the group to the (current/new) strip
                this.group.setTop(this.galleryHeight);
                this.strip.ratio += this.group.ratio;
                // this.strip.height = Math.min(targetItemSize, (galleryWidth / this.strip.ratio));
                this.strip.height = this.galleryWidth / this.strip.ratio;
                this.strip.setWidth(this.galleryWidth);
                this.strip.addGroup(this.group);
                if (this.isLastImage && this.strip.hasGroups) {
                    if (this.styleParams.scrollDirection === 1) {
                        this.strip.height =
                            this.container.galleryHeight +
                                (this.styleParams.imageMargin / 2 -
                                    this.styleParams.layoutParams.gallerySpacing);
                    }
                    else if (this.strip.canRemainIncomplete()) {
                        //stretching the this.strip to the full width will make it too high - so make it as high as the targetItemSize and not stretch
                        this.strip.height = this.targetItemSize;
                        this.strip.markAsIncomplete();
                    }
                    this.strip.resizeToHeight(this.strip.height);
                    this.galleryHeight += this.strip.height;
                    this.columns[0].addGroups(this.strip.groups);
                    this.strips.push(this.strip);
                }
            }
            else {
                //---------------------| COLUMNS GALLERY |----------------------//
                //find the shortest column
                var minCol = this.findShortestColumn(this.columns, this.groups.length - 1);
                //resize the group and images
                this.group.setCubedHeight(minCol.cubedHeight); //fix last column's items ratio (caused by stretching it to fill the screen)
                this.group.resizeToWidth(minCol.width);
                this.group.round();
                //update the group's position
                this.group.setTop(minCol.height);
                this.group.setLeft(minCol.left);
                //add the image to the column
                minCol.addGroup(this.group);
                //add the image height to the column
                minCol.height += this.group.totalHeight;
                if (this.galleryHeight < minCol.height) {
                    this.galleryHeight = minCol.height;
                }
            }
            if (!this.firstGroup) {
                this.firstGroup = this.group;
            }
            this.pointer++;
        }
        if (this.styleParams.forceFullHeight) {
            var stretchRatio_1 = this.container.galleryHeight / this.galleryHeight;
            this.items.map(function (item) {
                item.cubeImages = true;
                item.cropRatio = item.ratio = item.width / (item.height * stretchRatio_1);
                item.height *= stretchRatio_1;
                return item;
            });
            this.groups.map(function (group) {
                group.height *= stretchRatio_1;
                group.setTop(group.top * stretchRatio_1);
                group.resizeItems();
                return group;
            });
        }
        //results
        this.lastGroup = this.group;
        this.colWidth = Math.floor(this.galleryWidth / this.numOfCols);
        this.height =
            this.galleryHeight -
                (this.styleParams.imageMargin / 2 - this.styleParams.layoutParams.gallerySpacing) * 2;
        this.width = this.lastGroup.left + this.lastGroup.width;
        this.ready = true;
        return this.scheme;
    };
    Layouter.prototype.lastVisibleItemIdxInHeight = function (height) {
        for (var i = this.items.length - 1; i >= 0; i--) {
            var item = this.items[i];
            var isVisible = item.offset.top < height;
            if (isVisible) {
                return i;
            }
        }
        return this.items.length - 1;
    };
    Layouter.prototype.lastVisibleItemIdx = function () {
        //the item must be visible and about the show more button
        return this.lastVisibleItemIdxInHeight(this.container.galleryHeight - 100);
    };
    Layouter.prototype.findNeighborItem = function (itemIdx, dir) {
        var _this = this;
        var currentItem = this.layoutItems[itemIdx];
        var neighborItem;
        var findClosestItem = function (currentItemX, currentItemY, condition) {
            var minDistance = null;
            var minDistanceItem = {};
            var itemY;
            var itemX;
            var distance;
            // each(slice(this.layoutItems, itemIdx - 50, itemIdx + 50), (item) => {
            _this.layoutItems.forEach(function (item) {
                itemY = item.offset.top + item.height / 2;
                itemX = item.offset.left + item.width / 2;
                distance = Math.sqrt(Math.pow(itemY - currentItemY, 2) + Math.pow(itemX - currentItemX, 2));
                if ((minDistance === null || (distance > 0 && distance < minDistance)) &&
                    condition(currentItemX, currentItemY, itemX, itemY)) {
                    minDistance = distance;
                    minDistanceItem = item;
                }
            });
            return minDistanceItem;
        };
        switch (dir) {
            case 'up':
                neighborItem = findClosestItem(currentItem.offset.left + currentItem.width / 2, currentItem.offset.top, function (curX, curY, itmX, itmY) { return itmY < curY; });
                break;
            case 'left':
                neighborItem = findClosestItem(currentItem.offset.left, currentItem.offset.top + currentItem.height / 2, function (curX, curY, itmX) { return itmX < curX; });
                break;
            case 'down':
                neighborItem = findClosestItem(currentItem.offset.left + currentItem.width / 2, currentItem.offset.bottom, function (curX, curY, itmX, itmY) { return itmY > curY; });
                break;
            default:
            case 'right':
                neighborItem = findClosestItem(currentItem.offset.right, currentItem.offset.top + currentItem.height / 2, function (curX, curY, itmX) { return itmX > curX; });
                break;
        }
        if (neighborItem.idx >= 0) {
            return neighborItem.idx;
        }
        else {
            console.warn('Could not find offset for itemIdx', itemIdx, dir);
            return itemIdx; //stay on the same item
        }
    };
    Layouter.prototype.getMaxGroupSize = function () {
        var _maxGroupSize = 1;
        try {
            var groupTypes = typeof this.styleParams.groupTypes === 'string' &&
                this.styleParams.groupTypes.length > 0
                ? this.styleParams.groupTypes.split(',')
                : this.styleParams.groupTypes;
            _maxGroupSize =
                groupTypes.length > 0
                    ? groupTypes.reduce(function (curSize, groupType) { return Math.max(curSize, parseInt(groupType)); }, 1)
                    : Number(groupTypes);
            _maxGroupSize = Math.min(_maxGroupSize, this.styleParams.groupSize);
        }
        catch (e) {
            console.error("couldn't calculate max group size - returing 3 (?)", e);
            _maxGroupSize = 3;
        }
        return _maxGroupSize;
    };
    Object.defineProperty(Layouter.prototype, "isLastImage", {
        get: function () {
            return !this.srcItems[this.pointer + 1];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Layouter.prototype, "isLastImages", {
        get: function () {
            return !this.srcItems[this.pointer + 1];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Layouter.prototype, "imagesLeft", {
        get: function () {
            return this.srcItems.length - this.pointer - 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Layouter.prototype, "items", {
        get: function () {
            return this.layoutItems;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Layouter.prototype, "scheme", {
        get: function () {
            return {
                items: this.items.map(function (item) { return item.scheme; }),
                groups: this.groups.map(function (group) { return group.scheme; }),
                strips: this.strips.map(function (strip) { return strip.scheme; }),
                columns: this.columns.map(function (column) { return column.scheme; }),
                height: this.height,
                width: this.width,
            };
        },
        enumerable: false,
        configurable: true
    });
    return Layouter;
}());
export default Layouter;
/* eslint-enable prettier/prettier */
//# sourceMappingURL=layouter.js.map