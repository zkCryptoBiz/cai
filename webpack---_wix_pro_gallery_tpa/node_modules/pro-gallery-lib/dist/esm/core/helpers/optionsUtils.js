import { __assign, __spreadArray } from "tslib";
function assignByString(Obj, string, value, cloneObject) {
    if (cloneObject === void 0) { cloneObject = true; }
    var _obj = cloneObject ? __assign({}, Obj) : Obj;
    var keyArr = string.split('_');
    var assignedProperty = keyArr.pop();
    var pointer = _obj;
    keyArr.forEach(function (key) {
        if (typeof pointer[key] !== 'object')
            pointer[key] = {}; //if its not an object we put an object over it to allow assignments
        pointer = pointer[key];
    });
    pointer[assignedProperty] = value;
    return _obj;
}
function getByString(Obj, string) {
    var keyArr = string.split('_');
    var assignedProperty = keyArr.pop();
    var pointer = Obj;
    if (!keyArr.every(function (key) {
        if (typeof pointer[key] !== 'object')
            return false; //if its not an object there will be nothing in it...
        pointer = pointer[key]; //programatically going town the rabit hole
        return true;
    })) {
        return undefined;
    }
    else {
        return pointer[assignedProperty];
    }
}
function mutatingAssignMultipleByStrings(Obj, stringValuePairArray) {
    for (var _i = 0, stringValuePairArray_1 = stringValuePairArray; _i < stringValuePairArray_1.length; _i++) {
        var _a = stringValuePairArray_1[_i], string = _a[0], value = _a[1];
        Object.assign(Obj, assignByString(Obj, string, value));
    }
}
function flattenObject(ob) {
    var toReturn = {};
    for (var i in ob) {
        // eslint-disable-next-line no-prototype-builtins
        if (!ob.hasOwnProperty(i))
            continue;
        if (typeof ob[i] == 'object' &&
            !(ob[i] instanceof Array) &&
            ob[i] !== null &&
            Object.keys(ob[i]).length > 0) {
            var flatObject = flattenObject(ob[i]);
            for (var x in flatObject) {
                // eslint-disable-next-line no-prototype-builtins
                if (!flatObject.hasOwnProperty(x))
                    continue;
                toReturn[i + '_' + x] = flatObject[x];
            }
        }
        else {
            toReturn[i] = ob[i];
        }
    }
    return toReturn;
}
function flatToNested(ob) {
    var cloneObject = false;
    return Object.entries(ob).reduce(function (obj, _a) {
        var option = _a[0], value = _a[1];
        return assignByString(obj, option, value, cloneObject);
    }, {});
}
function trimUndefinedValues_nested(object) {
    var flatObject = flattenObject(object);
    Object.keys(flatObject).forEach(function (key) {
        return flatObject[key] === undefined ? delete flatObject[key] : {};
    });
    return flatToNested(flatObject);
}
function trimUndefinedValues_flat(flatObject) {
    Object.keys(flatObject).forEach(function (key) {
        return flatObject[key] === undefined ? delete flatObject[key] : {};
    });
    return flatObject;
}
function mergeNestedObjects() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return flatToNested(Object.assign.apply(Object, __spreadArray([{}], args.map(flattenObject), false)));
}
export { flattenObject, assignByString, flatToNested, mergeNestedObjects, getByString, mutatingAssignMultipleByStrings, trimUndefinedValues_nested, trimUndefinedValues_flat, };
//# sourceMappingURL=optionsUtils.js.map